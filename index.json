[{"authors":["admin"],"categories":null,"content":"このブログはあくまで会社もしくはその社員としての公式見解の場ではありません。全ての記事は個人としての発言です。このブログでは、リアルタイムグラフィックス関連で、興味のあることを取り扱っていきたいと思います。\n以前の記事はこちらにあります。 https://shikihuiku.wordpress.com/\nThis BLOG is a place to express things which I’m interested in, especially related to computer graphics, not for a place to discuss about my work or company. All things noted on this BLOG are based on my personal views.\nThank you.\nOld site is here, https://shikihuiku.wordpress.com/\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://shikihuiku.github.io/author/shikihuiku/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/shikihuiku/","section":"authors","summary":"このブログはあくまで会社もしくはその社員としての公式見解の場","tags":null,"title":"shikihuiku","type":"authors"},{"authors":[],"categories":[],"content":"this is a test page. ","date":1598954400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1598954400,"objectID":"22ea6b6fc168ada74695f77804c58ec4","permalink":"https://shikihuiku.github.io/post/timer_test/","publishdate":"2020-09-01T19:00:00+09:00","relpermalink":"/post/timer_test/","section":"post","summary":"this is a test page. ","tags":[],"title":"test post","type":"post"},{"authors":[],"categories":[],"content":"HLSLのWave Intrinsicsについて Wave Intrinsicsは、HLSLのShader Model6.0から導入された新しい組み込み関数群です。 従来の他のHLSL組み込み関数が、単一スレッド内での変数のみを動作の対象するのに対して、 Wave Intrinsicsは、Waveと呼ばれる複数のスレッド間でのデータの交換や演算を行うための組み込み関数となります。 従来は、Compute Shaderなどで、他のスレッドの変数（演算用のレジスタ）が保持する値を参照するには、groupsharedで宣言された変数やUAVなどで宣言されたバッファーに情報を一旦ストアする必要があったうえ、スレッド間の同期命令が必要でした。 Wave Intrinsicsは、Wave内のスレッド間に限定されますが、他のスレッドの変数（演算用のレジスタ）の値を参照したり演算することが出来ます。 これにより、スレッド間のレジスタ空間の共有が可能になり、複数のスレッドで協調的に動作するシェーダーコードが、より記述しやすくなりました。 また、Wave内は命令実行のタイミングが同じであることが（論理上において）保証されていることから、スレッド間同期命令を必要としないのも大きな利点です。 一点注意が必要なのは、Wave IntrinsicsはShader Model 6.0以上に存在する組み込み関数ですが、実際に使用できるかどうかは、ID3D12Device::CheckFeatureSupport()で、D3D12_FEATURE_D3D12_OPTIONS1を調べる必要があります。\n用語 ここではWave Intrinsicsに関連する用語を説明します。\nWave NVIDIAの用語で\u0026quot;warp\u0026quot;とよばれ、AMDの用語では、\u0026ldquo;wavefront\u0026quot;と呼ばれてきたものです。命令発行が、同時に行われれるスレッドのグループのことです。\nLane Waveを構成する個々のスレッドを指します。\n以下の図は、一つのWaveの中に32Lane分のスレッドが存在する場合の図になります。この図式を使って様々なWave Intrinsicsについて説明していきたいと思います。   WaveとLane   Inactive Lane Waveを構成する個々のスレッドのうち、命令を実行しないスレッドを指します。\nActive Lane Waveを構成する個々のスレッドのうち、命令を実行するスレッドを指します。\n以下の図は、左側のシェーダーコードの実行に伴って変化する、Active LaneとInactive Laneの変化の例を表した図です。右側の3 Laneは、スレッド起動数等の初期条件によるInactive Laneです。 Pixel ShaderやCompute Shaderで必要とされるスレッド数が、Waveの倍数でなかった場合は、Inactive Laneの存在するWaveが起動されます。このようなInactive Laneは、状態が動的に変更されることは無く、終始Inactive Laneのままです。 3行目のIf()による分岐の条件を満たさなかったLaneは、If()ステートで囲まれたコードブロックが終了するまでInactive Laneとなります。Wave内では命令実行は暗黙的に同期する決まりになっているので、Inactive Laneはその間なにも実行せず、他のLaneが該当コードブロックの実行を完了するまで待ちます。 図にはありませんが、If()ステートのコードブロックの実行が終了すれば、条件分岐によってInactive Laneとなったスレッドは、再びActive Laneへと復帰します。\n  Active LaneとInactive Lane   Quad 先頭から連続する4Lane分づつのスレッドのグループを指します。特にPixel Shaderでは、RenderTargetにおける2x2ピクセルブロックが一つのQuadにアサインされます。 Pixel Shaderにおけるddx/ddyなどのGradient命令や、テクスチャーのLoDの計算は、Quad内の変数の差分によって実現されており、Gradientの計算のみに寄与してPixelを塗らないLane（スレッド）をHelper Laneと呼びます。\n以下の図は、とあるプリミティブをレンダリングする際の、QuadとHelper LaneのRenderTarget上での表現とWaveとしての表現の対応図です。\n  QuadとHelper Lane   Waveのサイズについて Wave Intrinsicsを使う上で、Waveのサイズというは非常に重要なファクターで、これを理解すること無しに、効率的な処理をデザインすることは難しいと思います。 NVIDIAのWarpは、伝統的に32 Lane/Waveです。対して、AMDのGCNアーキテクチャは64 Lane/Waveで動作しています。 同じくAMDのRDNAアーキテクチャは、Wave32とWave64の二つの動作モードを持ち、それぞれが、32, 64 Lane/Waveで動作しています。 どちらのモードでシェーダーが実行されるかは、ドライバーが決定するようなので、シェーダーは両モードで正しく動く必要があります。結局のところ、32 Lane/Wave、64 Lane/Waveの両方をサポートすることができれば、NVIDIA, AMDの両GPUに対応したアプリケーションとなるはずです。\n  32 Lane/Waveと64 Lane/Wave   ID3D12Device::CheckFeatureSupport()のD3D12_FEATURE_D3D12_OPTIONS1では、Wave Intrinsicsの使用の可否についてとともに、使用される可能性のあるWaveのサイズの上限値と下限値が返されます。 したがって先のRDNAの様に、単一のアーキテクチャでも、Waveのサイズは可変であると考える必要があるのかもしれません。しかし、WaveのサイズのAPI仕様としての上限値と下限値である 4 と 128 はあまりにもかけ離れているため、Waveのサイズに依存するコードを記述する際に、すべてのWaveのサイズをサポートすることは非現実的です。また、実際には使用されないWaveのサイズのためにコードを書くのも無駄だと思います。したがって、現実的な実装方法としてはD3D12_FEATURE_D3D12_OPTIONS1でWaveのサイズの上限値と下限値をチェックし、32と64の範囲ならば、Wave Intrinsicsを使ったシェーダーコードを使用し、そうでない場合はWave Intrinsicsを使用していないフォールバックのシェーダーコードを実行するか、エラーを出力して動作を終了するべきだと思います。\nWaveのサイズは、WaveGetLaneCountというWave Intrinsicsを使って取得できます。しかし、これは裏を返せば、D3D12_FEATURE_D3D12_OPTIONS1のWaveの上限値と下限値に幅がある場合は、HLSLのシェーダーコードを実行するまで、Waveのサイズが分からないという事になります。（これはAPIのデザインの問題だと思います。）\nWaveのサイズとThread Groupのサイズについて Wave Intrinsicsは、あくまでWaveのサイズを基準とした動作になっていて、Compute Shaderのnumthreadsの大きさは、Waveのサイズとは関係ありません。ただし、Wave Intrinsicsを使う場合は、numthreadsの大きさはWaveのサイズを意識したものが良いと思います。 WaveのThread Group内でのマッピングは、Row Oriented　(X軸優先）です。（ただし、これを明記しているドキュメントが見当たらなかったので注意が必要です。）numthreadsの大きさが、Waveのサイズの倍数でなかった場合は、シェーダーが実行される前からInactive Laneが存在するWaveが起動されます。この場合、Waveのサイズ分のスレッドがすべて動作していることを前提として記述されたシェーダーは、動作が破綻するので注意が必要です。 現状では、ID3D12Device::CheckFeatureSupport()のD3D12_FEATURE_D3D12_OPTIONS1の返すWaveのサイズの上限値の倍数をnumthreadsの大きさとすることで、このような事態を回避する事ができると思います。\n  numthreadとWave   PixelShaderとWave Intrinsicsについて （これも明記しているドキュメントが見当たらなかったので注意してください）\nPixel Shaderでは、すべてのWave Intrinsicsの使用が許されています。しかし、Pixel Shaderにおける描画ピクセルとWaveやLaneの対応は、描画されるプリミティブの位置と、GPUとドライバー、そしてPixel Shaderのソースコードによって決まると考えられます。 シンプルな例では、ピクセルシェーダーのスレッドは描画されるプリミティブのピクセルと一対一の関係で起動されると思います。ただし、ピクセルシェーダー内で、Gradinet命令（ddx/ddy）を使用したり、テクスチャーのサンプリングにおいて、LoDを明示的に指定しなかった場合は、スレッド間の値（テクスチャサンプリングにおいてはUV値）の差分を計算する必要があるため、起動されるスレッドは2x2ピクセル単位となります。そして、プリミティブとして描画されるピクセルを担当しているスレッドのみがRenderTargetへの出力を行います。残りのスレッドは、Helper Laneとなり、スレッドとして動作しますがRenderTargetへの出力を行いません。 プリミティブの描画においては、必要なスレッド数は必ずしもWaveのサイズの倍数とならないので、シェーダー内で条件分岐を行っていない状態でも、Inactive Laneが存在しているWaveが起動される可能性があります。また、複数のプリミティブが同一のWaveにパッキングされる可能性もあります。Pixel Shader内でWave Intrinsicsを使う場合は、これらの点について考慮する必要があると思います。\n  QuadとHelper Lane   Shader Model 6.0のWave Intrinsicsについて Shader Model 6.0のWave Intrinsicsは以下のカテゴリに分類することができます。\n Wave Query\nWaveやLaneの状態取得 Wave Vote\nWave内でのbooleanステート確認 Wave Broadcast\nWave内で特定のLaneの変数値の取得 Wave Reduction\nWave内での変数の演算 Wave Scan and Prefix\nWave内での変数の演算(自身より小さいLane Indexに限る) Quad-wide Shuffle operations\nQuadを動作対象とした、変数値の取得  Wave Query WaveのLane数と、Lane Indexを調べるためのIntrinsicsです。\n加えて、Wave内で自身が先頭のActive Laneかどうかを返す、WaveIsFirstLaneが含まれます。\nWaveGetLaneCount WaveのLaneの数を返します。全てのLaneで同じ値を受け取ります。   WaveGetLaneIndex Wave内での該当LaneのIndexを返します。個々のLaneで異なる値を受け取ります。   WaveIsFirstLane bool値を返します。ActiveLaneの中で最小のLane IndexのLaneのみtrueが返されます。残りのLaneはfalseが返されます。   Wave Vote Wave内の他のActive Laneのboolのステータスを確認するためのIntrinsicsです。\nWaveActiveAnyTrue 引数にbool値を指定します。そして、いずれかのActive Laneがtrueを渡せば、全てのActive Laneにtrueが返されます。そうでない場合は、全てのActive Laneにfalseが返されます。\n  WaveActiveAllTrue 引数にbool値を指定します。全てのActive Laneがtrueを渡せば、全てのActive Laneにtrueが返されます。そうでない場合は、全てのActive Laneにfalseが返されます。\n  WaveActiveBallot 引数にbool値を指定します。戻り値にuint4を返します。戻り値のuint4は、128bit-wideのビットマスクとなっており、各Active Laneが渡したbool値をビットマスクとして返します。Inacive Laneは暗黙的に0が設定されます。\n  Wave Broadcast Wave内で、特定のLaneの変数の値を、すべてのActive Laneで取得するためのIntrinsicsです。\nWaveReadLaneAt 引数に、読み取りの対象となる変数とLane Indexを指定します。Lane Indexで指定されたLaneの、引数で指定された変数の値を、全てのActive Laneに返します。引数で指定した変数の型と同じ型が返されます。\n他にも、引数に指定した変数の型と同じ変数型を返すタイプのWave Intrinsicsがありますが、これらはベクトル型を含め、組み込み型の整数型と浮動小数点型の殆どがサポートされています。\n  WaveReadLaneFirst 引数に、読み取りの対象となる変数を指定します。Active Laneの中で、最小のLane IndexのLaneの、引数で指定された変数の値を、すべてのActive Laneに返します。\n  Wave Reduction Wave内でのActive Laneの変数の値を用いて演算するためのIntrinsicsです。一つの演算結果がすべてのActive Laneに返されます。\nWaveActiveAllEqual 引数に、読み取りの対象となる変数を指定します。すべてのActive Laneの変数の値が等しい場合のみTrueを返します。\n  WaveActiveBitAnd 引数に、読み取りの対象となる整数型の変数を指定します。すべてのActive Laneの変数の値のBitwise AND(論理積)を演算した結果を返します。\nWaveActiveBitOr 引数に、読み取りの対象となる整数型の変数を指定します。すべてのActive Laneの変数の値のBitwise OR(論理和)を演算した結果を返します。\nWaveActiveBitXor 引数に、読み取りの対象となる整数型の変数を指定します。すべてのActive Laneの変数の値のBitwise XOR(排他的論理和)を演算した結果を返します。\n  WaveActiveCountBits 引数に、boolを指定します。引数にtrueを指定したLaneの数を、すべてのActive Laneに返します。\n  WaveActiveMax 引数に、読み取りの対象となる変数を指定します。すべてのActive Laneの変数の値の中で、最大値を、全てのActive Laneに返します。\nWaveActiveMin 引数に、読み取りの対象となる変数を指定します。すべてのActive Laneの変数の値の中で、最小値を、全てのActive Laneに返します。\nWaveActiveProduct 引数に、読み取りの対象となる変数を指定します。すべてのActive Laneの変数をの値を乗算した結果を、全てのActive Laneに返します。 演算の順序については、API仕様としての明確な定義が無いので、扱う変数の型や、値の範囲について注意が必要です。\nWaveActiveSum 引数に、読み取りの対象となる変数を指定します。すべてのActive Laneの変数の値を加算した結果を、全てのActive Laneに返します。 演算の順序については、API仕様としての明確な定義が無いので、扱う変数の型や、値の範囲について注意が必要です。\n  Wave Scan and Prefix Wave Reduction系に似ていますが、演算の対象が自身のLane Index未満のActive Laneのみです。自身のLaneは演算の対象に含みません。 演算の結果は、基本的にはLaneごとに異なる値が返されることになります。\nWavePrefixCountBits 引数にboolを指定します。自身のLane Index未満のActive Laneで、引数にtrueを指定した個数を返します。\nWavePrefixSum 引数に、読み取りの対象となる変数を指定します。自身のLane Index未満のActive Laneの、変数の値を加算した結果を返します。 演算の順序については、API仕様としての明確な定義が無いので、扱う変数の型や、値の範囲について注意が必要です。[precise]フラグは無視されます。\nWavePrefixProduct 引数に、読み取りの対象となる変数を指定します。自身のLane Index未満のActive Laneの、変数の値を乗算した結果を返します。 演算の順序については、API仕様としての明確な定義が無いので、扱う変数の型や、値の範囲について注意が必要です。[precise]フラグは無視されます。\n  Quad-wide Shuffle operations Pixel Shaderでのみ使用可能なWave Intrinsicsです。 (これについては、2020/08現在ドキュメントの表記と実装に食い違いがあります。ドキュメントにはCompute Shaderでも使用可能と表記されており、その場合、Lane Indexの0より4 Laneごとに区切ったLaneがQuadとして扱われるとされています。 しかし実際には、Quad系を使用したCompute Shaderのコンパイル時にopcode 'QuadReadAcross' should only be used in 'Pixel Shader'というメッセージが出力されます。そして、シェーダーの生成にも失敗します。)\nQuadReadLaneAt 引数に、Quad内のローカルのLane Indexと、読み取り対象となる変数を指定します。Quad内で同じ値が返されます。 読み取り対象LaneがInactive Laneだった場合の読み取り結果は未定義なので注意が必要です。 Pixel ShaderにおけるQuad内のローカルのLane Indexは、下図に示した通りRow Orientedとなっています。\nQuadReadAcrossDiagonal 引数に、読み取り対象となる変数を指定します。Quad内で互いに対角の位置にあるLaneの値を読み取ります。(例えば、Lane:0はLane:3の値を受け取ります。) (APIドキュメントに明記がありませんが、読み取り対象LaneがInactive Laneだった場合の読み取り結果は未定義なので注意が必要です。)\nQuadReadAcrossX 引数に、読み取り対象となる変数を指定します。Quad内で互いに水平の位置にあるLaneの値を読み取ります。(例えば、Lane:0はLane:1の値を受け取ります。) (APIドキュメントに明記がありませんが、読み取り対象LaneがInactive Laneだった場合の読み取り結果は未定義なので注意が必要です。)\nQuadReadAcrossY 引数に、読み取り対象となる変数を指定します。Quad内で互いに垂直の位置にあるLaneの値を読み取ります。(例えば、Lane:0はLane:3の値を受け取ります。) (APIドキュメントに明記がありませんが、読み取り対象LaneがInactive Laneだった場合の読み取り結果は未定義なので注意が必要です。)\n  Shader Model 6.5のWave Intrinsicsについて Model 6.5で、いくつかの新しいWaveIntrinsicsが導入されています。\nWaveMatch 引数に、読み取り対象となる変数を指定します。\n戻り値にuint4を返します。戻り値のuint4は、128bit-wideのビットマスクとなっており、各Active Laneの引数で指定された変数の値が、自身のLaneの変数の値と等しい場合に、ビットがセットされます。Inacive Laneは暗黙的に0が設定されます。\n  WaveMultiPrefixSum 引数に、読み取り対象となる変数を指定します。また、引数に128bit-wideのビットマスクとなる uint4 を指定します。\nWaveActiveSumと動作は似ていますが、加算の対象となるLaneがビットマスクで指定されたLaneに限定される点が異なります。 ビットマスクは、Laneごとに設定を変更出来ますが、一つのLaneは1種類のビットマスクにしか所属する事ができません。 つまり、ビットマスクによって、Laneをパーティショニングしてサブセット化する事が出来ますが、各々のLaneが完全に自由にビットマスクを指定できるわけではありません。一つのLaneが複数の種類のビットマスクに所属した場合の動作は未定義です。\nWaveのサイズを超えるBitやInactive Laneのビットは無視されます。(ビットがゼロとして扱います。) このビットマスクの仕様は他のWaveMultiPrefix系と共通です。\n  WaveMultiPrefixProduct 引数に、読み取り対象となる変数を指定します。また、引数に128bit-wideのビットマスクとなるuint4を指定します。\nWaveActiveProductと動作は似ていますが、乗算の対象となるLaneがビットマスクで指定されたLaneに限定される点が異なります。\nWaveMultiPrefixCountBit 引数に、bool値を指定します。また、引数に128bit-wideのビットマスクとなるuint4を指定します。\nWaveActiveCountBitと動作は似ていますが、乗算の対象となるLaneがビットマスクで指定されたLaneに限定される点が異なります。\nWaveMultiPrefixAnd 引数に、読み取り対象となる整数型の変数を指定します。また、引数に128bit-wideのビットマスクとなるuint4を指定します。\nWaveActiveBitAndと動作は似ていますが、乗算の対象となるLaneがビットマスクで指定されたLaneに限定される点が異なります。\nWaveMultiPrefixOr 引数に、読み取り対象となる整数型の変数を指定します。また、引数に128bit-wideのビットマスクとなるuint4を指定します。\nWaveActiveBitOrと動作は似ていますが、乗算の対象となるLaneがビットマスクで指定されたLaneに限定される点が異なります。\nWaveMultiPrefixXor 引数に、読み取り対象となる整数型の変数を指定します。また、引数に128bit-wideのビットマスクとなるuint4を指定します。\nWaveActiveBitXorと動作は似ていますが、乗算の対象となるLaneがビットマスクで指定されたLaneに限定される点が異なります。\n終わりに 今回は、Wawve Intrinsicsの動作を理解するための基本的な内容となっているので、実際の使用ケースについては言及しませんでした。 次回は、もう少し実際の利用ケースについて触れたいと思います。\n","date":1597575632,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1597575632,"objectID":"d26efcbc36e3445c1245aed40fbb6ffc","permalink":"https://shikihuiku.github.io/post/wave_intrinsics1/","publishdate":"2020-08-16T20:00:32+09:00","relpermalink":"/post/wave_intrinsics1/","section":"post","summary":"Wave Intrinsicsの動作を理解しよう","tags":["D3D12","WaveIntrinsics"],"title":"HLSLのWave Intrinsicsについて","type":"post"},{"authors":[],"categories":[],"content":"動機とか タイトルの画像は、今まで運用してきたWordpress上のサイトのスクリーンショットです。記念に撮ってきました。\n別にWordpressがいやになったという訳ではないのですが、Github pagesに移行したほうが制約も少なく扱いやすい気がしたので引っ越しすることにしました。Wordpressに書いた記事は、簡単に移行するのは難しそうなので、そのままにしておきます。\nHugo＋Academic 別に十分な検討をしてこの組み合わせに至ったわけでは無く、静的サイト生成ツール＋なんか都合の良いTheme程度の認識で選択しました。今後変えるかもしれません。 ただ、コンテンツは多少特殊な要素があったとしても、基本的にMarkdownで記述できるので、今後もしサイトを移行しようと思っても、記事の移行をあきらめたくなるような事はないのではないでしょうか。\n導入手順 せかっくなので自分なりの導入手順を記しておきます。環境はWindows10を使用しています。Hugoは導入済です。\nAcademicの導入 まず、Hugoのテーマとして、Academicを導入しようとして、以下の様にファイルを配置しましたが、上手くいきませんでした。\ngit submodule add https://github.com/gcushen/hugo-academic.git themes/academic   Academicのドキュメントを参照すると、Hugoの新規サイトの状態に加えて、いろいろなファイルが正しい位置に配置されている必要があるようで、 academic-kickstart.gitをクローンすることがおすすめのようです。 初めはプライベートリポジトリとして扱いたいですし、リポジトリの名前も変えたいので、cloneしてmirrorします。\ngit clone --bare https://github.com/sourcethemes/academic-kickstart.git cd academic-kickstart.git git push --mirror https://github.com/shikihuiku/blog.git  早速ローカルで初期状態を確認しようと思ったら、ビルドエラーが出ました。\n\u0026gt; hugo server Building sites … ERROR 2020/07/25 17:30:35 render of \u0026quot;term\u0026quot; failed: execute of template failed: template: authors/list.html:5:3: executing \u0026quot;authors/list.html\u0026quot; at \u0026lt;partial \u0026quot;site_head\u0026quot; .\u0026gt;: error calling partial: \u0026quot;T:\\GitHub\\hugotest\\blog\\themes\\academic\\layouts\\partials\\site_head.html:131:56\u0026quot;: execute of template failed: template: partials/site_head.html:131:56: executing \u0026quot;partials/site_head.html\u0026quot; at \u0026lt;resources.Concat\u0026gt;: error calling Concat: resources in Concat must be of the same Media Type, got \u0026quot;text/x-scss\u0026quot; and \u0026quot;text/css\u0026quot; ERROR 2020/07/25 17:30:35 render of \u0026quot;section\u0026quot; failed: execute of template failed: template: section/publication.html:5:3: executing \u0026quot;section/publication.html\u0026quot; at \u0026lt;partial \u0026quot;site_head\u0026quot; .\u0026gt;: error calling partial: \u0026quot;T:\\GitHub\\hugotest\\blog\\themes\\academic\\layouts\\partials\\site_head.html:131:56\u0026quot;: execute of template failed: template: partials/site_head.html:131:56: executing \u0026quot;partials/site_head.html\u0026quot; at \u0026lt;resources.Concat\u0026gt;: error calling Concat: resources in Concat must be of the same Media Type, got \u0026quot;text/x-scss\u0026quot; and \u0026quot;text/css\u0026quot; ERROR 2020/07/25 17:30:35 render of \u0026quot;home\u0026quot; failed: execute of template failed: template: index.html:5:3: executing \u0026quot;index.html\u0026quot; at \u0026lt;partial \u0026quot;site_head\u0026quot; .\u0026gt;: error calling partial: \u0026quot;T:\\GitHub\\hugotest\\blog\\themes\\academic\\layouts\\partials\\site_head.html:131:56\u0026quot;: execute of template failed: template: partials/site_head.html:131:56: executing \u0026quot;partials/site_head.html\u0026quot; at \u0026lt;resources.Concat\u0026gt;: error calling Concat: resources in Concat must be of the same Media Type, got \u0026quot;text/x-scss\u0026quot; and \u0026quot;text/css\u0026quot; ERROR 2020/07/25 17:30:35 render of \u0026quot;taxonomy\u0026quot; failed: execute of template failed: template: authors/terms.html:5:3: executing \u0026quot;authors/terms.html\u0026quot; at \u0026lt;partial \u0026quot;site_head\u0026quot; .\u0026gt;: error calling partial: \u0026quot;T:\\GitHub\\hugotest\\blog\\themes\\academic\\layouts\\partials\\site_head.html:131:56\u0026quot;: execute of template failed: template: partials/site_head.html:131:56: executing \u0026quot;partials/site_head.html\u0026quot; at \u0026lt;resources.Concat\u0026gt;: error calling Concat: resources in Concat must be of the same Media Type, got \u0026quot;text/x-scss\u0026quot; and \u0026quot;text/css\u0026quot; ERROR 2020/07/25 17:30:35 failed to render pages: render of \u0026quot;section\u0026quot; failed: execute of template failed: template: section/talk.html:5:3: executing \u0026quot;section/talk.html\u0026quot; at \u0026lt;partial \u0026quot;site_head\u0026quot; .\u0026gt;: error calling partial: \u0026quot;T:\\GitHub\\hugotest\\blog\\themes\\academic\\layouts\\partials\\site_head.html:131:56\u0026quot;: execute of template failed: template: partials/site_head.html:131:56: executing \u0026quot;partials/site_head.html\u0026quot; at \u0026lt;resources.Concat\u0026gt;: error calling Concat: resources in Concat must be of the same Media Type, got \u0026quot;text/x-scss\u0026quot; and \u0026quot;text/css\u0026quot; Built in 84 ms Error: Error building site: TOCSS: failed to transform \u0026quot;main_parsed.scss\u0026quot; (text/x-scss): resource \u0026quot;scss/scss/main.scss_76ac6956597c32fec7ddf60d408db3ab\u0026quot; not found in file cache  調べてみると、Academicには、hugo_extendedが必要だという事が分かりましたので、 Hugo_extendedのビルド済バイナリをDLします。 再びローカルサーバーを立ち上げると、今回は上手くビルドできました。\nhugo server  ローカルホストのポート1313にアクセスすると、おしゃれなサイトが表示されました。BiographyやProjectsやPublicationsなど、かなりハイスペック人材向けのテンプレートで尻込みしますが、どんどん削っていくことにします。\nAcademicのカスタマイズ ここで先人の知恵をお借りします\n Hugo + Academic テーマを使ったブログの作り方 https://qiita.com/harumaxy/items/58e7e4273c61e7e260b3\n /config/_default/フォルダに格納されている以下のtomlファイルを編集していきます。\n config.toml language.toml menus.toml params.toml  その他諸々の変更を行って、シンプルにBlogのポストができるページにしました。言語設定はenのまま使用する事にします。\nフォントの設定 デフォルトでは、GoogleのWebフォントがいろいろ指定されていますが、フォントの設定はシンプルな方が良いと思っています。 フォントのプリセットにNativeという設定があり、こちらを使うとrootのfont-familyの設定を、殆どの要素で使うようになるようです。config/_default/params.tomlでこれを指定します。\n font=\u0026quot;Native\u0026rdquo;\n rootにある、フォントの設定はとりあえず変更せずに使ってみます。\ncustom.scssの設定 デフォルトではブラウザの横幅に対してページの表示領域が酷く狭いです。\nblog/assets/scss/custom.scssというファイルを配置することで、自身で記述したcssをページに読み込ませる事が出来るようです。生成されたHTMLの要素のクラス名を確認して適当に設定しました。なんだか横幅を変えるだけで泥臭い作業になりました。もっと簡単にスタイルを変更する方法があるかもしれません。\n/*width for top page*/ .container { max-width: 90%; } /*width for posts.*/ .article-container{ max-width:90% }  また、見出しのフォントのWeightが一定では無いので変更します。ついでにマージンも変更します。 この辺りは素人なので、あまり参考になりませんが。 しかし、CSSを書いて変更できると結局楽だなってなって思ってきました\u0026hellip;\nh1, h2, h3, h4, h5, h6 { margin-top: 1.7rem; margin-bottom: 0.3rem; font-weight: 700; }  アイコンの設定 それから、Webサイトのアイコン、所謂ファビコンがデフォルトの設定では、Academicのアイコンになっているので変更します。\nassets/images/フォルダに、解像度512x512のicon.pngを配置します。\nGithub Pagesの設定 最後に、実際にビルドされたページをGithub Pagesでホスティングする方法ですが、一番簡単な方法はHugoの出力先をdocsフォルダにして、それをそのままリポジトリにPushして、GithubPagesで公開する方法だと思います。 Hugoはデフォルトではpublicフォルダにファイルが生成されるので、これを変更します。\nconfig/_default/config.tomlに以下の様に設定することで、docsフォルダにサイトが生成されるようになります。\npublishdir= \u0026quot;docs\u0026quot;  あとは、baseurlを設定しサイトを生成してエラーがでなければOKです。リポジトリにPushして、github pagesの設定をすれば公開されます。\nGithub Pagesの設定 - やっぱりPrivateリポジトリで 構築履歴が閲覧可能な状態なのは別に構わないですし、大抵の場合はDraft記事が閲覧可能な状態でも構わないのですが、一部のCEDECセッションの補間資料とかのDraftは会期以前に公開状態になるのはまずいので、 publishしたべージのコンテンツのみを公開状態にする必要があります。結局Hugoのpublishdirのディレクトリ以下を別のリポジトリにして、こちらだけPublicに設定して、ビルド環境はPrivateリポジトリにすることにしました。\n","date":1595462400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595462400,"objectID":"1a9a117957ea8d71e8aeec5a04f15ce9","permalink":"https://shikihuiku.github.io/post/hello_hugo_and_academic/","publishdate":"2020-07-23T00:00:00Z","relpermalink":"/post/hello_hugo_and_academic/","section":"post","summary":"永らくWordpressでダラダラと記事をPostしてきましたが、Wordpressであることのメリットがほとんど活かせてない状況です。自分は静的サイトが作れれば十分なので、引っ越すことにしました。","tags":["Hugo","Academic"],"title":"Hugo+Academicでブログを構築","type":"post"},{"authors":[],"categories":[],"content":"この記事は、旧サイトからテスト用に移植しました。  入力遅延の問題はゲーム開発において悩ましい問題の一つです。特にPCでは、他のプロセスが勝手な都合で動作しますし、リソースの競合も発生します。また、PC本体のCPU/GPUパフォーマンスの違いも大きいです。ここでは一般的なデスクトップPC上で、フォートナイトの描画がどのように実行されているかをソフトウェアの見地から、GPUViewを用いて観測してみます。ここで言う入力遅延は、Windows上のゲームのプロセスがキーやマウスのステートを取得すると思われるタイミングから、描画された画面が、ディスプレイへの出力対象になるまでを指します。実際には、マウスやキーボードのハードウェアとドライバにも遅延がありますし、ディスプレイにも実際に輝点として可視化されるまでに遅延がありますが、これらは今回は考慮しません。またゲームのプロセスが正確にいつ入力デバイスの情報を取得しているかは考慮しません。あるフレームのCPU処理の開始を入力取得時間として考えます。\nちなみに今回使用したデスクトップPCは、Core-i7 7700KとGeForce RTX2080Tiが搭載されています。モニタは一般的な60Hzの4Kディスプレイです。\nテストに使ったシーンは、クリエイティブの島です。描画としては極めて軽い状態がテスト対象です。\nUE4の開発者の方は、すでにご存じかと思いますが、以下の資料に入力遅延に関する詳しい解説がご覧いただけると思います。\n\n UE4のスレッドの流れと Input Latency改善の仕組み  from エピック・ゲームズ・ジャパン Epic Games Japan 今回は、フォートナイトをプレイする上でどのような設定が一番自分にとって好ましいかを調べる過程で分かったことを説明していきます。フォートナイトの描画設定で、入力遅延に関係のある設定は、フレームレートの上限値、VSync、それから、マルチスレッドレンダリングです。描画APIはD3D11と12に対応していますが、D3D12にすることによる利点があまり感じられなかったため、今回はD3D11のみをテストしています。\nVSync: OFF マルチスレッドレンダリング: OFF フレームレート上限: 60   vsyncoff_mtoff_60   おなじみのGPUViewのログです。詳しく見たい方はクリックして拡大してください。まずは、スレッドのアクティビティを理解するために一番簡単な例を示します。VSyncがOffなので、青い縦線で示されたVSyncのタイミングとは全く関係なく描画されています。描画スレッドが、D3D11の描画APIを呼び出して、Present()を呼び出し、GPUが描画を完了するのとほぼ同時にフロントバッファへのFlipが行われ、ディスプレイへの表示対象になります。ドライバのスレッドに描画命令を発行しているスレッドが、UE4のRHIスレッドと思われますが、マルチスレッドレンダリングをOffにしているので、Renderのスレッドが、直接RHIを呼び出しているのではないかと思われます。それに先立ち動作しているスレッドがゲームのメインスレッドと思われます。ゲームのメインスレッドは、Render/RHIスレッドに渡す描画情報を構築するタイミングと思われるところで、フレームレートのペーシングを行っていると思われます。計測された入力遅延は、12.8msですが、CPUもGPUもアイドル時間が長いので、処理クロックを落としていると思われます。実際の場合も何も小細工しなければ、ユーザーの知らないところでクロックが下がるので、今回はこの設定の入力遅延は12ms前後と考えます。\nVSync: OFF マルチスレッドレンダリング: ON フレームレート上限: 60 次は、先ほどの設定から、マルチスレッドレンダリングを有効にしてみます。他の設定は同じです。\n  vsyncoff_mton_60   見た目ががらりと変わっていますが、アイドリングしているWorkerスレッドにRenderと思われるスレッドが埋もれてしまったため、このような見た目になっています。実際は、どの設定でも多数のWorkerスレッドやサウンドのスレッドが立ち上げられていますが、描画に関係ないものは省略しています。先ほどの例と異なり、RHIのスレッドと思われるスレッドと、Renderと思われるスレッドが別になりました。基本的な仕組みや、遅延の状況はほぼ同じです。こちらもおそらく動作クロックが下がっているので、本来の描画パフォーマンスと比べると処理時間がかかっています。\nVSync: OFF マルチスレッドレンダリング: OFF フレームレート上限: 120   vsyncoff_mtoff_120   次は、再びマルチスレッドレンダリングをOFFに戻しました。そして、フレームレート上限を120にしてみました。基本的な動作は一番初めの例と同じですが、フレームのペーシングが8.3msになったことで、120FPSのレンダリングになりました。そして、アイドリングのデューティ比が変わったことにより、動作クロックが引き上げられた関係で、入力遅延も短縮され、9.5ms程度になりました。\nVSync: OFF マルチスレッドレンダリング: ON フレームレート上限: 120 次は、上記の設定でマルチスレッドレンダリングをONにします。   vsyncoff_mton_120   やはり、RenderスレッドとRHIスレッドが分かれました。今回のテスト対象になっているシーンは軽いので、マルチスレッドレンダリングの恩恵は少ないですが、もっと複雑なシーンでは、これらのスレッドが並列動作することにより、Renderスレッドの描画命令発行によるストールが軽減され、より顕著な差になると思われます。少なくとも遅くなることはなさそうなので、私はこの設定でプレイすることにします。\nVSync: ON マルチスレッドレンダリング: OFF フレームレート上限: 制限なし 次は、いわゆる、VSyncを守って、画面のティアリングを起こさない描画になります。見た目は一番スムーズなのですが、入力遅延の観点からはあまりお勧めできない設定となりそうです。   vsyncon_mtoff_60   まず、VSyncを取ると、メインスレッドの動作がかなり変わります。およそ2ms単位でスレッドをポーリングしながら、処理開始のタイミングを計っているようです。rhi.SyncSlackMSのデフォルト設定と思われる、VSyncの10ms前に、メインスレッドの処理を開始しています。Renderスレッドは、前の前のフレームのGPU描画処理が完了してから、RHIの呼び出しを開始しているようです。そして、RHIが呼び出すD3DAPIによって生成されたGPUタスクは、ドライバのGPUタスクキューに積み上げられます。そのフレームのGPU描画処理がGPU上で実行されるのは、Renderスレッドが動作したフレームの次の次のフレームです。そして、ディスプレイの出力対象になるFlipが行われるのは、VSyncに同期しているので、実際の表示はその次のフレームとなります。メインスレッドが動作を開始してから、ディスプレイの出力対象になるまでの入力遅延は60msほどとなります。\nまとめ 少なくとも私の環境では、VSyncをOFFにして、CPUのフレームペーシングがボトルネックになる状態（つまりGPUの処理時間には余裕がある状態）で、なるべく高いフレームレートが入力遅延が一番小さくなる状態だといえると思います。入力遅延を最短にするという目的ならば、私のPCでは、おそらく200フレーム以上の設定の方が短くなると思われます。しかし、使用しているディスプレイも60Hzですし、描画解像度など他の設定に妥協が必要になります。 また、これらの状況は、個々のPCの、CPUとGPUの処理能力のバランスによって変動するので、皆さんに一概にこの設定がおすすめですとはなりません。しかし、VSyncはOff、なるべく早いCPU、なるべく早いGPU、なるべく軽い描画が、入力遅延低減につながると思われます。\n","date":1592238782,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592238782,"objectID":"117dad02d1f9ebb737d4f2c72538fd7f","permalink":"https://shikihuiku.github.io/post/check_input_latency_of_fortnite/","publishdate":"2020-06-16T01:33:02+09:00","relpermalink":"/post/check_input_latency_of_fortnite/","section":"post","summary":"タイトルは緩いですけど、ゲーム開発者向けの話です。プラットフォームはPC限定です。","tags":["DX11","GPUView","UE4","Fortnite"],"title":"フォートナイトの入力遅延を観測してみた","type":"post"}]