<!DOCTYPE html><html lang="en-us" >

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.8.0">

  

  
  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="shikihuiku">

  
  
  
    
  
  <meta name="description" content="D3D12の夢のあるはなし">

  
  <link rel="alternate" hreflang="en-us" href="https://shikihuiku.github.io/post/d3d12utm/">

  


  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  

  
  
  
  
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css" integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin="anonymous">
    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js" integrity="sha256-Md1qLToewPeKjfAHU1zyPwOutccPAm5tahnaw7Osw0A=" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      
        
      

      
    
      

      
      

      
    

  

  
  
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.min.3934cd053659c69f72130ea239611b5f.css">

  




  


  
  

  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/images/icon_hu127225d7ed9c50974404790b7c221374_401884_32x32_fill_lanczos_center_3.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hu127225d7ed9c50974404790b7c221374_401884_192x192_fill_lanczos_center_3.png">

  <link rel="canonical" href="https://shikihuiku.github.io/post/d3d12utm/">

  
  
  
  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="shikihuiku – 色不異空 – Real-time rendering topics in Japanese.">
  <meta property="og:url" content="https://shikihuiku.github.io/post/d3d12utm/">
  <meta property="og:title" content="ID3D12CommandQueue::UpdateTileMappingsが起こすデッドロックについて | shikihuiku – 色不異空 – Real-time rendering topics in Japanese.">
  <meta property="og:description" content="D3D12の夢のあるはなし"><meta property="og:image" content="https://shikihuiku.github.io/images/icon_hu127225d7ed9c50974404790b7c221374_401884_512x512_fill_lanczos_center_3.png">
  <meta property="twitter:image" content="https://shikihuiku.github.io/images/icon_hu127225d7ed9c50974404790b7c221374_401884_512x512_fill_lanczos_center_3.png"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2025-02-01T18:00:00&#43;09:00">
    
    <meta property="article:modified_time" content="2025-02-01T18:00:00&#43;09:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://shikihuiku.github.io/post/d3d12utm/"
  },
  "headline": "ID3D12CommandQueue::UpdateTileMappingsが起こすデッドロックについて",
  
  "datePublished": "2025-02-01T18:00:00+09:00",
  "dateModified": "2025-02-01T18:00:00+09:00",
  
  "author": {
    "@type": "Person",
    "name": "shikihuiku"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "shikihuiku – 色不異空 – Real-time rendering topics in Japanese.",
    "logo": {
      "@type": "ImageObject",
      "url": "https://shikihuiku.github.io/images/icon_hu127225d7ed9c50974404790b7c221374_401884_192x192_fill_lanczos_center_3.png"
    }
  },
  "description": "D3D12の夢のあるはなし"
}
</script>

  

  


  


  





  <title>ID3D12CommandQueue::UpdateTileMappingsが起こすデッドロックについて | shikihuiku – 色不異空 – Real-time rendering topics in Japanese.</title>

</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class=" ">

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  












<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">shikihuiku – 色不異空 – Real-time rendering topics in Japanese.</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">shikihuiku – 色不異空 – Real-time rendering topics in Japanese.</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-end" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
            
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="https://shikihuiku.wordpress.com/" target="_blank" rel="noopener"><span>Old Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>About</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/memo"><span>ちらしの裏</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      <li class="nav-item dropdown theme-dropdown">
        <a href="#" class="nav-link js-theme-selector" data-toggle="dropdown" aria-haspopup="true">
          <i class="fas fa-palette" aria-hidden="true"></i>
        </a>
        <div class="dropdown-menu">
          <a href="#" class="dropdown-item js-set-theme-light">
            <span>Light</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-dark">
            <span>Dark</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-auto">
            <span>Automatic</span>
          </a>
        </div>
      </li>
      

      

    </ul>

  </div>
</nav>



  <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>ID3D12CommandQueue::UpdateTileMappingsが起こすデッドロックについて</h1>

  
  <p class="page-subtitle">Deadlocks Caused by ID3D12CommandQueue::UpdateTileMappings</p>
  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    2025/02/01
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    22 min read
  </span>
  

  
  
  

  
  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style">
      <p>English is here. 
<a href="#Eng">Deadlocks Caused by ID3D12CommandQueue::UpdateTileMappings</a></p>
<p>D3D12のゲームが低い頻度でハングアップしてしまう理由の一つとして、<code>UpdateTilemappnigs</code>が原因となるデッドロックがあります。詳しい仕組みは、いまだ不明ですが、最近やっと自分の考えを人に説明できるぐらいにはなってきたので、メモ代わりに残しておこうと思います。<br>
ただし、以下に記述することは、あくまでも、おそらくこういうことだろうなぁ、という程度の想像の話です。確かなことはSDKやOSを設計している人に聞いてみないとわかりません。
今のところ、Windows11 24H2 (OS Build 26100.2894)では起きるようですが、将来的にOS側に修正が入る可能性もあるかと思います。</p>
<h2 id="gpuviewで確認するd3d12のid3d12commandqueueupdatetilemappingsの動作">GPUViewで確認するD3D12のID3D12CommandQueue::UpdateTileMappingsの動作</h2>
<p>まずは、GPUViewを使って<code>UpdateTileMappings</code>の動作を確認してみます。GPUViewのEvent Listの中から、<code>DxgKrnl UpdateGPUVirtualAddress</code>を選択して、呼び出し箇所を特定します。
以下のスクリーンショットは、あるフレームのレンダリング処理を、プロセスのGPU実行キューに積んだ後に、<code>UpdateTileMappings</code>（以下UTM）を何度か呼び出している箇所です。<br>
UTMの呼び出しで、アプリケーションのスレッドがカーネルモードにスイッチしているのがわかります。また、その区間では、<code>DxgKrnl UpdateGPUVirtualAddress</code>のイベント一つにつき、フェンスが二つ設定されているのがわかります。</p>






  



  
  











<figure class="center" id="figure-gpu-view---1">


  <a data-fancybox="" href="/post/d3d12utm/image1_hub9ccdd4ec5701d8ba5db3e6a9b8229e2_36733_2000x2000_fit_lanczos_3.png" data-caption="GPU View - 1">


  <img data-src="/post/d3d12utm/image1_hub9ccdd4ec5701d8ba5db3e6a9b8229e2_36733_2000x2000_fit_lanczos_3.png" class="lazyload" alt="" width="90%" height="978">
</a>


  
  
  <figcaption>
    GPU View - 1
  </figcaption>


</figure>

<p>次に、このフェンスがプロセスのGPU実行キューで処理されるタイミングを見てみます。まず、積み上げられたフェンスは同一のオブジェクトなのがわかります。１つのフェンスが、フェンス値をインクリメントしながら使用されているようです。UTMのフェンスが、プロセスのGPU実行キューの先頭に到達すると、アプリケーションのスレッドでDPCが呼び出されます（これはOSによる割り込みと解釈して問題ありません。）このDPCは、プロセスのPaging QueueにPaging Queu Packetを送出します。<br>
以下のスクリーンショットでは、UTMが送出した一連のフェンスをハイライトしています。先頭が、実行キューの先頭に到達する直前で、アプリケーションの白いバーで示されているThread上で、DPCが起動されます。このDPCが動作するタイミングでPaging Queue Packetが送出されますようです。矢印で図示しておきました。</p>






  



  
  











<figure class="center" id="figure-gpu-view---2">


  <a data-fancybox="" href="/post/d3d12utm/image2_hu3213b80c4faf65051a2dffba27d98fa5_481072_2000x2000_fit_lanczos_3.png" data-caption="GPU View - 2">


  <img data-src="/post/d3d12utm/image2_hu3213b80c4faf65051a2dffba27d98fa5_481072_2000x2000_fit_lanczos_3.png" class="lazyload" alt="" width="90%" height="1000">
</a>


  
  
  <figcaption>
    GPU View - 2
  </figcaption>


</figure>

<p>送出されたPaging Queue Packetは、OSのVidMm WorkerThreadで処理されます。パケットを受け取ったOSのスレッドが、System Paging Contextに、Paging Command Packetを送出します。このパケットは、GPU上のHardware Copy Queueに送出されて、GPU上で処理されます。</p>






  



  
  











<figure class="center" id="figure-gpu-view---3">


  <a data-fancybox="" href="/post/d3d12utm/image3_hu92bebf72723ca2a2ad84b4939408949e_84146_2000x2000_fit_lanczos_3.png" data-caption="GPU View - 3">


  <img data-src="/post/d3d12utm/image3_hu92bebf72723ca2a2ad84b4939408949e_84146_2000x2000_fit_lanczos_3.png" class="lazyload" alt="" width="90%" height="896">
</a>


  
  
  <figcaption>
    GPU View - 3
  </figcaption>


</figure>

<p>System Paging Contextには、Paging Command Packetの直後に、３つのフェンスが設定されており、GPU上でのUTM処理の完了をCPU側で検知するようです。このうちの一つは、UTMを送出したプロセスのスレッドでDPCを起動して、これがUTMのフェンスのフェンス値をインクリメントするようです。その結果、プロセス側のGPU実行QueueでUTMの完了を待っていたフェンスが解決されます。これで一つのUTM処理が完了したことになります。</p>






  



  
  











<figure class="center" id="figure-gpu-view---4">


  <a data-fancybox="" href="/post/d3d12utm/image4_huce2858e525986fbbb1701b9fc14dc36c_412330_2000x2000_fit_lanczos_3.png" data-caption="GPU View - 4">


  <img data-src="/post/d3d12utm/image4_huce2858e525986fbbb1701b9fc14dc36c_412330_2000x2000_fit_lanczos_3.png" class="lazyload" alt="" width="90%" height="1017">
</a>


  
  
  <figcaption>
    GPU View - 4
  </figcaption>


</figure>

<h2 id="utmの処理をwindbgで追ってみる">UTMの処理をWindbgで追ってみる</h2>
<p>次は、デバッガーを使って、UTMの処理を追ってみます。適当なサンプルアプリケーションのUTMコールを、Microsoftのシンボルサーバーだけを使って追ってみました。処理は、D3Dのランタイム、ユーザーモードドライバー、Windows APIなどで構成されており、その中で主だった処理を、順を追って見てみたいと思います。</p>
<h4 id="1-d3d12coreが管理するmutexの取得">1. D3D12Coreが管理するMutexの取得</h4>
<p>UTM呼び出しの冒頭で、D3D12Coreが管理するミューテックスを取得します。おそらくこれは、該当の<code>CGraphicsCommandQueue</code>に対する呼び出しの、排他制御の為と思われます。<code>CGraphicsCommandQueue</code>はスレッドセーフな設計となっているので、必要に応じてD3Dのランタイム側でで排他制御が行われているのだと思われます。</p>
<pre><code>[0x0]   ntdll!RtlAcquireSRWLockExclusive     
[0x1]   msvcp_win!Mtx_lock+0x31    
[0x2]   D3D12Core!std::_Mutex_base::lock+0x10    
[0x3]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0xe2    
</code></pre>
<h4 id="2-device-driver-interfaceに登録された関数の呼び出し">2. Device Driver Interfaceに登録された関数の呼び出し</h4>
<p>Device Driver Interface (DDI)は、OSやランタイムが、デバイスドライバーを呼び出すときの関数のインターフェースです。呼び出し先は、その時インストールされているドライバーのコードになります。呼び出されたDDIの引数のを見ると、<code>d3d12umddi.h</code>に定義されている、<code>PFND3D12DDI_UPDATETILEMAPPINGS</code>だとわかります。</p>
<pre><code>[0x2]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0x3]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e      
</code></pre>
<p>参考：<code>d3d12umddi.h</code>の<code>PFND3D12DDI_UPDATETILEMAPPINGS</code>の定義</p>
<pre><code>typedef VOID ( APIENTRY* PFND3D12DDI_UPDATETILEMAPPINGS )( D3D12DDI_HCOMMANDQUEUE, D3D12DDI_HRESOURCE,
    UINT NumTiledResourceRegions,
    _In_reads_(NumTiledResourceRegions) const D3D12DDI_TILED_RESOURCE_COORDINATE* pResourceRegionStartCoords,
    _In_reads_opt_(NumTiledResourceRegions) const D3D12DDI_TILE_REGION_SIZE* pResourceRegionSizes,
    D3D12DDI_HHEAP, UINT NumRanges,
    _In_reads_opt_(NumRanges) const D3D12DDI_TILE_RANGE_FLAGS*,
    _In_reads_opt_(NumRanges) const UINT* pHeapStartOffsets,
    _In_reads_opt_(NumRanges) const UINT* pRangeTileCounts,
    D3D12DDI_TILE_MAPPING_FLAGS );
</code></pre>
<h4 id="3-umdのコード内でのcritical-sectionの取得">3. UMDのコード内でのCritical Sectionの取得</h4>
<p>Critical SectionはWindwosが提供するる、プロセス内で使える同期オブジェクトです。Callstackを見ると、UMDのコードが<code>nvwgf2umx!OpenAdapter</code>となっていますが、これは、UMDのDLLでExportされているSymbolからのオフセットアドレスを表示しているだけで、DDIコールで<code>OpenAdapter</code>が呼ばれているわけではありません。NVIDIAのUMDのDLLのPDBファイルが無いので、Symbolが解決できないだけです。</p>
<pre><code>[0x0]   ntdll!RtlEnterCriticalSection   
[0x1]   nvwgf2umx!OpenAdapter12+0x7e5f   
[0x2]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0x3]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<h4 id="4-フェンスのシグナルの送出">4. フェンスのシグナルの送出</h4>
<p>次に、UMDのUTM処理コードは、D3DCoreの、<code>SubmitSignalSyncObjectsToHwQueueCB</code>を呼び出します。このコールバックは、OSがD3DRuntimeに登録するコールバックと思われます。登録されているコールバック関数は、<code>win32u!NtGdiDdDDISubmitSignalSyncObjectsToHwQueue</code>のようです。この関数のアセンブラコードを見ると、すぐに<code>syscall</code>を実行して、カーネルモードに入っています。ここまでの呼び出し経路は少々複雑で、Application→D3DRuntime→UMD→D3DRuntime→GDIとなっています。</p>
<pre><code>[0x0]   win32u!NtGdiDdDDISubmitSignalSyncObjectsToHwQueue+0x12   
[0x1]   D3D12Core!CallAndLogImpl&lt;long (__cdecl*)(_D3DKMT_SUBMITSIGNALSYNCOBJECTSTOHWQUEUE const * __ptr64),_D3DKMT_SUBMITSIGNALSYNCOBJECTSTOHWQUEUE * __ptr64&gt;+0x1d   
[0x2]   D3D12Core!NDXGI::CDevice::SubmitSignalSyncObjectsToHwQueueCB+0xdd   
[0x3]   nvwgf2umx!....
....
[0xa]   nvwgf2umx!....
[0xb]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0xc]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<p>参考：<code>NtGdiDdDDISubmitSignalSyncObjectsToHwQueue</code>のアセンブラコード</p>
<pre><code>win32u!NtGdiDdDDISubmitSignalSyncObjectsToHwQueue:
mov     r10, rcx
mov     eax, 125Dh
test    byte ptr [7FFE0308h], 1
jne     win32u!NtGdiDdDDISubmitSignalSyncObjectsToHwQueue+0x15
syscall 
ret   
</code></pre>
<h4 id="5-d3dkmt_updategpuvirtualaddressの呼び出し">5. D3DKMT_UPDATEGPUVIRTUALADDRESSの呼び出し</h4>
<p>ついにUTMの処理の本体とも呼べる箇所に到達しました。呼び出し経路は、先ほどのシグナルと似た経路です。こちらもGDIの関数で、関数内部で、すぐに<code>sycall</code>を実行するだけです。処理の実体はカーネルモードにあると思います。</p>
<pre><code>[0x0]   win32u!NtGdiDdDDIUpdateGpuVirtualAddress+0x12   
[0x1]   D3D12Core!CallAndLogImpl&lt;long (__cdecl*)(_D3DKMT_UPDATEGPUVIRTUALADDRESS const * __ptr64),_D3DKMT_UPDATEGPUVIRTUALADDRESS * __ptr64&gt;+0x11   
[0x2]   D3D12Core!NDXGI::CDevice::UpdateGpuVirtualAddressCB+0x64   
[0x3]   nvwgf2umx!....
....
[0x8]   nvwgf2umx!....
[0x9]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0xa]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<p>参考：<code>NtGdiDdDDIUpdateGpuVirtualAddress</code>のアセンブラコード</p>
<pre><code>win32u!NtGdiDdDDIUpdateGpuVirtualAddress:
mov     r10, rcx
mov     eax, 1264h
test    byte ptr [7FFE0308h], 1
jne     win32u!NtGdiDdDDIUpdateGpuVirtualAddress+0x15 (7ff81e415f15)
syscall 
ret     
</code></pre>
<h4 id="6-フェンスのウエイトの設定">6. フェンスのウエイトの設定</h4>
<p><code>D3DKMT_UPDATEGPUVIRTUALADDRESS</code>が呼ばれた後に、フェンスのウエイトの設定処理があります。私の環境では複数回呼び出されていました。こちらも、GDI関数で処理され、処理の本体は、カーネルモードで実行されています。</p>
<pre><code>[0x0]   win32u!NtGdiDdDDISubmitWaitForSyncObjectsToHwQueue+0x12   
[0x1]   D3D12Core!CallAndLogImpl&lt;long (__cdecl*)(_D3DKMT_SUBMITWAITFORSYNCOBJECTSTOHWQUEUE const * __ptr64),_D3DKMT_SUBMITWAITFORSYNCOBJECTSTOHWQUEUE * __ptr64&gt;+0x1d   
[0x2]   D3D12Core!NDXGI::CDevice::SubmitWaitForSyncObjectsToHwQueueCB+0x4d   
[0x3]   nvwgf2umx!...
...
[0xa]   nvwgf2umx!... 
[0xb]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0xc]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<pre><code>win32u!NtGdiDdDDISubmitWaitForSyncObjectsToHwQueue:
mov     r10, rcx
mov     eax, 125Eh
test    byte ptr [7FFE0308h], 1
jne     win32u!NtGdiDdDDISubmitWaitForSyncObjectsToHwQueue+0x15 (7ff81e415e55)
syscall 
ret     
</code></pre>
<h4 id="7-umdのコードで取得したcritical-sectionの解放">7. UMDのコードで取得したCritical Sectionの解放</h4>
<p>冒頭で、UMDが取得したCritical Sectionをリリースしています。</p>
<pre><code>[0x0]   ntdll!RtlLeaveCriticalSection   
[0x1]   nvwgf2umx!...
[0x2]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0x3]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<h4 id="8-d3dcoreのmutexの解放">8. D3DCoreのMutexの解放</h4>
<p>冒頭で、D3DRuntimeが取得したMutexをリリースしています。</p>
<pre><code>[0x0]   ntdll!RtlReleaseSRWLockExclusive   0xc9a75ffd18   0x7ff81e8a366b   
[0x1]   msvcp_win!Mtx_unlock+0x1b   0xc9a75ffd20   0x7fff94976bd8   
[0x2]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x168   0xc9a75ffd50   0x7ff6e60e183d   
</code></pre>
<h3 id="windbgで確認できるutmの動作のまとめ">Windbgで確認できるUTMの動作のまとめ</h3>
<ul>
<li>CommandQueueごとの排他制御と思われるMutex（D3DRuntime管理）を取得している。</li>
<li>UMDのコード内でCritical Sectionを取得している。（これはGPUやドライバーによって異なる可能性がある）</li>
<li>以下のGDI関数を呼び出している（いずれも処理の本体はカーネルモード）
<ul>
<li>NtGdiDdDDISubmitSignalSyncObjectsToHwQueue</li>
<li>NtGdiDdDDIUpdateGpuVirtualAddress</li>
<li>NtGdiDdDDISubmitWaitForSyncObjectsToHwQueue</li>
</ul>
</li>
</ul>
<h2 id="d3dkmtupdategpuvirtualaddressの仕様について">D3DKMTUpdateGpuVirtualAddressの仕様について</h2>
<p>参考：

<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/d3dkmthk/nf-d3dkmthk-d3dkmtupdategpuvirtualaddress" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/d3dkmthk/nf-d3dkmthk-d3dkmtupdategpuvirtualaddress</a></p>
<p>上記のページのRemarksの最後の部分に、重要なことが記述されています。</p>
<blockquote>
<p>ドライバーは多くのUpdateGpuVirtualAddress呼び出しを送信できますが、それはレンダリングフェンスの後ろにキューイングされます。
キューイングされた更新操作の数が128を超えると、呼び出し元のスレッドはビデオメモリマネージャーによって以前の操作が処理されるまでブロックされます。</p>
</blockquote>
<p>つまり、UTMはID3D12CommandQueueのメソッドなので、大量のUTM処理を発行したとしても、それはCommandQueueに蓄積されるだけではないかと我々は想像してしまいますが、実際は、最大で128リクエストしか蓄積することができず、これを超えると、前に発行したUTMが完了するまで処理がブロックされるということがこのドキュメントから分かります。</p>
<h2 id="utmのデッドロック条件">UTMのデッドロック条件</h2>
<p>UTMのデッドロックは、おそらく先ほど説明した、128以上のUTM処理の蓄積によっておこるUTM処理のブロッキングに起因するものと思われます。このブロッキングの解消には、前に発行したUTM処理がGPU上で完了する必要があります。<br>
UTMは、<code>ID3D12CommandQueue</code>のメソッドなので、UTMの直前までに実行キューに積まれたすべての処理が完了し、UTM処理を開始するためのフェンスがシグナルされるまで処理は開始されません。もしも、UTMを実行キューに積む前にフェンスのウエイトが設定されて、それが解決しない状況に陥ればデッドロックになることが予想されます。<br>
しかし、一般的に、フェンスが解決しない状況はUTMの動作とは関係なくデッドロック状態に陥るので、UTM特有の問題とは言えません。では、何がUTM特有なのかというと、UTM処理のブロッキング、つまり前に発行したUTMの処理完了待ちをどこで行っているかというところです。
これは、UTMデッドロックに陥っているプロセスのメモリダンプを見るとわかるのですが、UTMのブロッキングは、<code>⁠win32u!NtGdiDdDDIUpdateGpuVirtualAddress</code> 内の<code>syscall</code>の箇所、つまりカーネル空間の処理の最中に行われます。<br>
先の章で、WinDbgでUTMの処理をトレースした際に確認しましたが、この箇所に到達するまでに、D3D12Coreにあるミューテックスを取得して、UMDの中でCiritical Sectionを取得しています。他にも、GDIレイヤーのカーネル空間でも排他処理が行われているかもしれません。もしも、これらの排他処理が、UTMより先に設定されたウエイトをシグナルするために必要な処理をブロックした場合はデッドロックが成立します。
そんなことが実際に起きるのか？と疑問に思うのは自然なことだと思います。しかし次の章で、UMTブロッキング時に競合する他のAPIのリストを見れば納得できると思います。</p>
<h2 id="utmの排他リソースと競合する処理">UTMの排他リソースと競合する処理</h2>
<p>では、UTMブロッキング時に競合する他の処理を見てみましょう。<br>
D3DCoreのミューテックスとUMDのCritical Sectionは、デバッガで追えば競合している状況を確認できます。しかし、複数のUTMデッドロックを起こしたプロセスのメモリダンプを確認すると、どうやらカーネル空間で処理が行われているGDI関数の方にも排他処理が存在するようです。<br>
ここでは、UTMのデッドロックが発生しているプロセスのメモリダンプでよく観測される箇所、つまり、UTMブロッキングで処理が停止する可能性の高い処理をリストアップしたいと思います。</p>
<h4 id="id3d12commandqueueexecutecommandlists">ID3D12CommandQueue::ExecuteCommandLists</h4>
<p>私の経験上、最もよく見かけます。
D3DCoreの中で、ミューテックスを取得しようとして失敗するため、<code>NtWaitForAlertByThreadId</code> でスリープして待機状態に入っています。
このミューテックスがUTMが確保したものならば、おそらく同じコマンドキューに対するECLなので、ミューテックスの取得に失敗して待機するのは納得がいきます。しかし、この処理は、UTMの後にキューに積まれるべき処理のはずなので、UTMデッドロックの直接の原因にはならないでしょう。</p>
<h4 id="id3d12commandqueuesignal">ID3D12CommandQueue::Signal</h4>
<p>Signalは、D3DCoreから、直接Win32uの<code>NtGdiDdDDISubmitSignalSyncObjectsToHwQueue</code> を呼び出し、<code>syscall</code>の中で止まっているのを観測します。
私の考えでは、UTMのキューに設定されたウエイトをシグナルするための、他のキューに設定されるべきシグナルが設定できないためにデッドロックが発生します。
したがって、シグナルを呼んでいるスレッドが<code>syscall</code>の中で止まっているというのは、大変興味深いです。</p>
<h4 id="id3d12fenceseteventoncompletion">ID3D12Fence::SetEventOnCompletion</h4>
<p>この処理は、<code>D3D12Core!CFence::SetEventOnCompletion</code>から、<code>D3D12Core!CDevice::SetEventOnMultipleFenceCompletion</code>というメソッドを呼んでいるので、API上は、<code>ID3D12Fence</code>ですが、実質上は、<code>ID3D12Device</code>の処理だと考えたほうがよさそうです。
最終的には、<code>NtGdiDdDDIWaitForSynchronizationObjectFromCpu</code> を呼び出し、<code>syscall</code>の中で止まっているのを観測します。</p>
<h4 id="id3d12devicecreateplacedresource">ID3D12Device::CreatePlacedResource</h4>
<p>このメソッドは、私の環境では、UMDから、<code>D3D12Core!NDXGI::CDevice::UpdateGpuVirtualAddressCB</code>を呼び出し、最終的には、<code>NtGdiDdDDIUpdateGpuVirtualAddress</code>を呼び出しています。
途中から、<code>ID3D12CommandQueue::UpdateTileMappings</code>と同じコードパスを辿ります。UTMと同じカーネル呼び出しですので、競合するのは理解ができます。</p>
<h4 id="id3d12fencerelease">ID3D12Fence::Release()</h4>
<p>観測した中で、最も意外だったのが、フェンスオブジェクトの解放処理である、<code>Release()</code>です。この処理は最終的に、<code>NtGdiDdDDIDestroySynchronizationObject</code>を呼び出しているのですが、この関数の<code>syscall</code>で止まっているのが複数回観測できました。</p>
<h2 id="utmデッドロックの回避方法">UTMデッドロックの回避方法</h2>
<p>まとめです。D3D12のAPIのユーザーとして、どのようなことに気を付ければ、UTMデッドロックを回避できるのでしょうか。</p>
<h3 id="プログラム側でutmの発行回数を制限する">プログラム側で、UTMの発行回数を制限する</h3>
<p>いろいろと考えられますが、最も効果的な方法を一つだけ提案します。それは、UTMの発行数をアプリ側で監視して制御する方法です。<br>
具体的な方法は、UTM専用のスレッド、UTM専用のCopyQueue、UTM専用のフェンスを用意して、UTMの呼び出しごとに、シグナルを設定して、フェンス値をインクリメントします。そして、UTMを呼び出す前に、<code>GetCompletedValue()</code>でGPU側での完了状況をチェックして、128個以上キューに積まれそうな状況では、<code>SetEventOnCompletion()</code>を使って、先に発行されたUTMの完了を待ちます。こうして、128個以上UTMがコマンドキューに積みあがらないようににプログラム側で調整します。GraphicsQueueや、ComputeQueueとの同期が必要な場合は、随時UTM専用のCopyQueueとフェンスを設定して同期します。</p>
<h4 id="なぜ専用のスレッドを用意するのか">なぜ専用のスレッドを用意するのか</h4>
<p>まず、<code>SetEventOnCompletion()</code>で、スレッドを待機させなければならない状況も考えられるので、専用のスレッドを用意するのは自然な考えです。
加えて、UTMの呼び出しは、もともとCPU側のフェンス処理を伴います。GPU Viewで観測したとおり多数のDPCコールが発生することが予想されます。これらは、UTMのスレッドからCPU時間を奪い取り、L1キャッシュの状態を乱す可能性があります。ならば、UTMの呼び出し元はUTMの処理に特化し、単純な処理をするスレッドにしておくべきです。</p>
<h4 id="なぜ専用のcopyqueueを用意するのか">なぜ専用のCopyQueueを用意するのか</h4>
<p>専用のCopyQueueを使う第一の理由は、UTMの個数を正確に数えるためです。UTMブロッキングの128という条件は、コマンドキューごとの数で、プロセス内で発行された総数ではありません。極端な話をすれば、コマンドキューを二つ用意して、UTMを分散すると、256個までUTMを発行できます。
専用のキューを用意してフェンスで他のキューと同期をとるのは、一見するとオーバーヘッドの高い処理に感じるかもしれません。しかし、UTMの処理は、もともとOSのメモリマネージャーによる処理を伴い、フェンスでUTMの発行されたキューと同期をとっています。つまり、もともとオーバーヘッドの高い処理なのです。<br>
他のGraphicsQueueやComputeQueueとフェンスで同期すれば、結局それらのキューはUTMのキューを待つことになり、全体の実行スピードは変わらないかもしれません。しかし、GraphicsQueueやComputeQueueがUTMのキューを長時間待つのを観測できれば、UTMと同期するフェンスの位置を調整したり、他の依存関係のない処理を挿入したりして最適化を行うことができます。ちなみに、UTMの処理は、GPU上ではHWCopyQueue上で非常に短時間に処理されます。つまり、UTM処理中は、GPUの演算ユニットはアイドリングしているのです。上手くスケジューリングすることができればUTMのGPUコストを隠蔽することができます。</p>
<h2 id="まとめ">まとめ</h2>
<p>結局、UTMに起因するデッドロックの発生の仕組みは予測の域を出ません。また、ほかにもUTMデッドロックを回避する手法はありますが、UTMブロッキングが発生すると、様々なD3DAPIがブロックされることが分かっており、マルチスレッドで動作するプログラムにおいて、これは多数のレンダリングに関連するスレッドが同時にストールする可能性を意味します。つまり、UTMブロッキングが発生している時点で、すでにプログラムとしては大きな性能の問題に直面しているのです。だとするならば、UTMデッドロックを避けるだけでなく、UTMブロッキング自体を起こさないようにアプリケーションで制御するしかないのが現状です。<br>
APIやドライバモデルの設計から一度やり直した方がよいのではないかという気がしてきます。</p>
<hr>
<p>以下英語版</p>
<hr>
<p><a id="Eng"></a></p>
<h1 id="deadlocks-caused-by-id3d12commandqueueupdatetilemappings">Deadlocks Caused by ID3D12CommandQueue::UpdateTileMappings</h1>
<p>One of the reasons for hang-ups happening infrequently in D3D12 games is a deadlock caused by <code>UpdateTileMappings</code>. Its precise mechanism is still unknown, but recently I&rsquo;ve been able to compile my observations on this issue to be able to explain to others, so I&rsquo;d like to leave this note as a memo.<br>
However, what I will describe below is merely a guess that it could probably be happening in the system. The exact details can only be confirmed by asking the people who design the SDK and the OS. Additionally, the survey has been done with the current latest OS, Windows 11 24H2 (OS Build 26100.2894), and the issue I&rsquo;m going to descrbie would be fixed in the future.</p>
<h2 id="observing-the-behavior-of-id3d12commandqueueupdatetilemappings-with-gpuview">Observing the behavior of ID3D12CommandQueue::UpdateTileMappings with GPUView</h2>
<p>Let&rsquo;s use GPUView to check the behavior of <code>UpdateTileMappings</code>. In the GPUView&rsquo;s event list, select <code>DxgKrnl UpdateGPUVirtualAddress</code> to identify the call sites. The following screenshot shows a section where, after rendering process for a frame has been enqueued in the process&rsquo;s GPU execution queue, <code>UpdateTileMappings</code> (from here, we call this UTM) is called several times. During the UTM calls, we can find that the application&rsquo;s thread switches to kernel mode. Also we can see that two fences are set for each UTM call.</p>






  



  
  











<figure class="center" id="figure-gpu-view---1">


  <a data-fancybox="" href="/post/d3d12utm/image1_hub9ccdd4ec5701d8ba5db3e6a9b8229e2_36733_2000x2000_fit_lanczos_3.png" data-caption="GPU View - 1">


  <img data-src="/post/d3d12utm/image1_hub9ccdd4ec5701d8ba5db3e6a9b8229e2_36733_2000x2000_fit_lanczos_3.png" class="lazyload" alt="" width="90%" height="978">
</a>


  
  
  <figcaption>
    GPU View - 1
  </figcaption>


</figure>

<p>Next, let&rsquo;s observe the timing when these fences are started to be processed in the process&rsquo;s GPU execution queue. First, you can see that the stacked fence objects are identical. It appears that a single fence object is used with incrimenting its fence value. When the UTM&rsquo;s fence reaches the front of the process&rsquo;s GPU execution queue, a DPC (Deferred Procedure Call) is invoked on the application&rsquo;s thread (which can be interpreted as an OS interrupt). This DPC sends a Paging Queue Packet to the process&rsquo;s paging queue. In the following screenshot, the fence object sent out by the UTMs is highlighted. Just before the head of the series of fences from the UTM reaches the front of the execution queue, a DPC is initiated on the thread indicated by the white bar of the application&rsquo;s thread, then, a Paging Queue Packet seems to be sent out while the DPC is working. I have illustrated this with red arrows.</p>






  



  
  











<figure class="center" id="figure-gpu-view---2">


  <a data-fancybox="" href="/post/d3d12utm/image2_hu3213b80c4faf65051a2dffba27d98fa5_481072_2000x2000_fit_lanczos_3.png" data-caption="GPU View - 2">


  <img data-src="/post/d3d12utm/image2_hu3213b80c4faf65051a2dffba27d98fa5_481072_2000x2000_fit_lanczos_3.png" class="lazyload" alt="" width="90%" height="1000">
</a>


  
  
  <figcaption>
    GPU View - 2
  </figcaption>


</figure>

<p>The dispatched Paging Queue Packet is processed by the OS&rsquo;s VidMm Worker Thread. The OS thread that receives the packet sends a Paging Command Packet to the System Paging Context. This packet is then sent to the Hardware Copy Queue on the GPU, where it is actually processed.</p>






  



  
  











<figure class="center" id="figure-gpu-view---3">


  <a data-fancybox="" href="/post/d3d12utm/image3_hu92bebf72723ca2a2ad84b4939408949e_84146_2000x2000_fit_lanczos_3.png" data-caption="GPU View - 3">


  <img data-src="/post/d3d12utm/image3_hu92bebf72723ca2a2ad84b4939408949e_84146_2000x2000_fit_lanczos_3.png" class="lazyload" alt="" width="90%" height="896">
</a>


  
  
  <figcaption>
    GPU View - 3
  </figcaption>


</figure>

<p>In the System Paging Context, three fences are set immediately after the Paging Command Packet. It seems these are used to detect the completion of the UTM processing on the GPU side on the CPU side. One of these fences appears to trigger a DPC on the thread of the process that originally sent out the UTM. The DPC then increments the fence value of the UTM. As a result, the fence that was waiting for the UTM to complete in the process&rsquo;s GPU execution queue is resolved. This means that one UTM processing is completed.</p>






  



  
  











<figure class="center" id="figure-gpu-view---4">


  <a data-fancybox="" href="/post/d3d12utm/image4_huce2858e525986fbbb1701b9fc14dc36c_412330_2000x2000_fit_lanczos_3.png" data-caption="GPU View - 4">


  <img data-src="/post/d3d12utm/image4_huce2858e525986fbbb1701b9fc14dc36c_412330_2000x2000_fit_lanczos_3.png" class="lazyload" alt="" width="90%" height="1017">
</a>


  
  
  <figcaption>
    GPU View - 4
  </figcaption>


</figure>

<h2 id="tracking-utm-processing-with-windbg">Tracking UTM Processing with Windbg</h2>
<p>Next, let&rsquo;s use a debugger to track the UTM processing. I traced a UTM call of a sample application using only Microsoft&rsquo;s symbol server. The process consists of the D3D runtime, user-mode driver, and Windows API. I would like to list out some major processing steps in order.</p>
<h4 id="1-acquiring-the-mutex-managed-by-d3d12core">1. Acquiring the Mutex Managed by D3D12Core</h4>
<p>At the beginning of the UTM call, a mutex managed by D3D12Core is acquired. It is likely that this is for mutual exclusion control for calls to the same <code>CGraphicsCommandQueue</code>. As <code>CGraphicsCommandQueue</code> interface is designed to be thread-safe, it appears that the D3D runtime manages mutual exclusion control as needed.</p>
<pre><code>[0x0]   ntdll!RtlAcquireSRWLockExclusive     
[0x1]   msvcp_win!Mtx_lock+0x31    
[0x2]   D3D12Core!std::_Mutex_base::lock+0x10    
[0x3]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0xe2    
</code></pre>
<h4 id="2-calling-the-function-registered-in-the-device-driver-interface">2. Calling the Function Registered in the Device Driver Interface</h4>
<p>The Device Driver Interface (DDI) is an interface for functions used by the OS and runtime to call device drivers. The call destination will be the code of the installed driver. Judging by the arguments of the call of the DDI, it&rsquo;s clear that this is <code>PFND3D12DDI_UPDATETILEMAPPINGS</code> defined in <code>d3d12umddi.h</code>.</p>
<pre><code>[0x2]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0x3]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e      
</code></pre>
<p>FYI, the definition of <code>PFND3D12DDI_UPDATETILEMAPPINGS</code> in <code>d3d12umddi.h</code></p>
<pre><code>typedef VOID ( APIENTRY* PFND3D12DDI_UPDATETILEMAPPINGS )( D3D12DDI_HCOMMANDQUEUE, D3D12DDI_HRESOURCE,
    UINT NumTiledResourceRegions,
    _In_reads_(NumTiledResourceRegions) const D3D12DDI_TILED_RESOURCE_COORDINATE* pResourceRegionStartCoords,
    _In_reads_opt_(NumTiledResourceRegions) const D3D12DDI_TILE_REGION_SIZE* pResourceRegionSizes,
    D3D12DDI_HHEAP, UINT NumRanges,
    _In_reads_opt_(NumRanges) const D3D12DDI_TILE_RANGE_FLAGS*,
    _In_reads_opt_(NumRanges) const UINT* pHeapStartOffsets,
    _In_reads_opt_(NumRanges) const UINT* pRangeTileCounts,
    D3D12DDI_TILE_MAPPING_FLAGS );
</code></pre>
<h4 id="3-acquiring-a-critical-section-in-the-umd-code">3. Acquiring a Critical Section in the UMD Code</h4>
<p>A Critical Section is a synchronization object provided by Windows OS that can be used within a process. Looking at the call stack, it shows <code>nvwgf2umx!OpenAdapter</code> for the UMD code, but this simply indicates the offset address from an exported symbol in the UMD&rsquo;s DLL, not that <code>OpenAdapter</code> is actually being called by the DDI call. Since we don&rsquo;t have the PDB file for NVIDIA&rsquo;s UMD DLL, the symbol cannot be resolved properly.</p>
<pre><code>[0x0]   ntdll!RtlEnterCriticalSection   
[0x1]   nvwgf2umx!OpenAdapter12+0x7e5f   
[0x2]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0x3]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<h4 id="4-setting-a-fence-signal">4. Setting a Fence Signal</h4>
<p>Next, it calls <code>SubmitSignalSyncObjectsToHwQueueCB</code> of D3DCore. This callback is likely registered by the OS in the D3D runtime. The registered callback function appears to be <code>win32u!NtGdiDdDDISubmitSignalSyncObjectsToHwQueue</code>. By checking the assembly code of this function, I found it almost immediately called a <code>syscall</code> to enter kernel mode. The call path up to this point is somewhat complex: Application → D3D Runtime → UMD → D3D Runtime → GDI.</p>
<pre><code>[0x0]   win32u!NtGdiDdDDISubmitSignalSyncObjectsToHwQueue+0x12   
[0x1]   D3D12Core!CallAndLogImpl&lt;long (__cdecl*)(_D3DKMT_SUBMITSIGNALSYNCOBJECTSTOHWQUEUE const * __ptr64),_D3DKMT_SUBMITSIGNALSYNCOBJECTSTOHWQUEUE * __ptr64&gt;+0x1d   
[0x2]   D3D12Core!NDXGI::CDevice::SubmitSignalSyncObjectsToHwQueueCB+0xdd   
[0x3]   nvwgf2umx!....
....
[0xa]   nvwgf2umx!....
[0xb]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0xc]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<p>FYI the code snippet of <code>NtGdiDdDDISubmitSignalSyncObjectsToHwQueue</code></p>
<pre><code>win32u!NtGdiDdDDISubmitSignalSyncObjectsToHwQueue:
mov     r10, rcx
mov     eax, 125Dh
test    byte ptr [7FFE0308h], 1
jne     win32u!NtGdiDdDDISubmitSignalSyncObjectsToHwQueue+0x15
syscall 
ret   
</code></pre>
<h4 id="5-calling-d3dkmt_updategpuvirtualaddress">5. Calling D3DKMT_UPDATEGPUVIRTUALADDRESS</h4>
<p>Finally, we have reached the core processing part of UTM. The call path is similar to that of the signaling the fence mentioned earlier. This is also a GDI function, and it immediately executes a <code>syscall</code> within the function. The actual processing seems to be in kernel mode.</p>
<pre><code>[0x0]   win32u!NtGdiDdDDIUpdateGpuVirtualAddress+0x12   
[0x1]   D3D12Core!CallAndLogImpl&lt;long (__cdecl*)(_D3DKMT_UPDATEGPUVIRTUALADDRESS const * __ptr64),_D3DKMT_UPDATEGPUVIRTUALADDRESS * __ptr64&gt;+0x11   
[0x2]   D3D12Core!NDXGI::CDevice::UpdateGpuVirtualAddressCB+0x64   
[0x3]   nvwgf2umx!....
....
[0x8]   nvwgf2umx!....
[0x9]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0xa]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<p>FYI, the code snippet of <code>NtGdiDdDDIUpdateGpuVirtualAddress</code></p>
<pre><code>win32u!NtGdiDdDDIUpdateGpuVirtualAddress:
mov     r10, rcx
mov     eax, 1264h
test    byte ptr [7FFE0308h], 1
jne     win32u!NtGdiDdDDIUpdateGpuVirtualAddress+0x15 (7ff81e415f15)
syscall 
ret     
</code></pre>
<h4 id="6-setting-fence-waits">6. Setting Fence Waits</h4>
<p>After <code>D3DKMT_UPDATEGPUVIRTUALADDRESS</code> is called, it sets some fence waits from the UMD code in my environment. This processing is also handled by a GDI function executed in kernel mode.</p>
<pre><code>[0x0]   win32u!NtGdiDdDDISubmitWaitForSyncObjectsToHwQueue+0x12   
[0x1]   D3D12Core!CallAndLogImpl&lt;long (__cdecl*)(_D3DKMT_SUBMITWAITFORSYNCOBJECTSTOHWQUEUE const * __ptr64),_D3DKMT_SUBMITWAITFORSYNCOBJECTSTOHWQUEUE * __ptr64&gt;+0x1d   
[0x2]   D3D12Core!NDXGI::CDevice::SubmitWaitForSyncObjectsToHwQueueCB+0x4d   
[0x3]   nvwgf2umx!...
...
[0xa]   nvwgf2umx!... 
[0xb]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0xc]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<pre><code>win32u!NtGdiDdDDISubmitWaitForSyncObjectsToHwQueue:
mov     r10, rcx
mov     eax, 125Eh
test    byte ptr [7FFE0308h], 1
jne     win32u!NtGdiDdDDISubmitWaitForSyncObjectsToHwQueue+0x15 (7ff81e415e55)
syscall 
ret     
</code></pre>
<h4 id="7-releasing-the-critical-section-acquired-in-the-umd-code">7. Releasing the Critical Section Acquired in the UMD Code</h4>
<p>The UMD acquired a critical section at the beginning, which is now being released.</p>
<pre><code>[0x0]   ntdll!RtlLeaveCriticalSection   
[0x1]   nvwgf2umx!...
[0x2]   D3D12Core!TableFunctionTraits&lt;2&gt;::Detail::InvokerImpl&lt;TableFunctionTraitsImpl&lt;2&gt;::FunctionTraits&lt;70,0,void&gt;,void,void,D3D12DDI_HCOMMANDQUEUE,D3D10DDI_HRESOURCE,unsigned int,D3D12DDI_TILED_RESOURCE_COORDINATE const * __ptr64,D3D12DDI_TILE_REGION_SIZE const * __ptr64,D3D12DDI_HHEAP,unsigned int,enum D3D12DDI_TILE_RANGE_FLAGS const * __ptr64,unsigned int const * __ptr64,unsigned int const * __ptr64,enum D3D12DDI_TILE_MAPPING_FLAGS&gt;::Call&lt;CGraphicsCommandQueue&gt;+0x9f   
[0x3]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x15e   
</code></pre>
<h4 id="8-releasing-the-mutex-managed-by-d3dcore">8. Releasing the Mutex managed by D3DCore</h4>
<p>At the end, D3D runtime releases the mutex that was acquired at the beginning of the UMD.</p>
<pre><code>[0x0]   ntdll!RtlReleaseSRWLockExclusive   0xc9a75ffd18   0x7ff81e8a366b   
[0x1]   msvcp_win!Mtx_unlock+0x1b   0xc9a75ffd20   0x7fff94976bd8   
[0x2]   D3D12Core!CGraphicsCommandQueue::UpdateTileMappings+0x168   0xc9a75ffd50   0x7ff6e60e183d   
</code></pre>
<h3 id="summary-of-the-utm-behavior">Summary of the UTM Behavior</h3>
<ul>
<li>Acquiring a mutex (managed by the D3D runtime) likely for mutual exclusion control per CommandQueue object.</li>
<li>Acquiring a critical section within UMD code.  (This may vary depending on the GPU or driver used.)</li>
<li>Calling the following GDI functions. (Most of the processing for these functions are in kernel mode.)
<ul>
<li><code>NtGdiDdDDISubmitSignalSyncObjectsToHwQueue</code></li>
<li><code>NtGdiDdDDIUpdateGpuVirtualAddress</code></li>
<li><code>NtGdiDdDDISubmitWaitForSyncObjectsToHwQueue</code></li>
</ul>
</li>
</ul>
<h2 id="specifications-of-d3dkmtupdategpuvirtualaddress">Specifications of D3DKMTUpdateGpuVirtualAddress</h2>
<p>FYI：

<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/d3dkmthk/nf-d3dkmthk-d3dkmtupdategpuvirtualaddress" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/d3dkmthk/nf-d3dkmthk-d3dkmtupdategpuvirtualaddress</a></p>
<p>The last part of the remarks section on the page above says important information.</p>
<blockquote>
<p>Drivers can submit many UpdateGpuVirtualAddress calls, which will be queued behind the rendering fence. When the number of queued update operations exceeds 128, the calling thread will be blocked until the previous operations are processed by the video memory manager.</p>
</blockquote>
<p>That is to say, since UTM is a method of ID3D12CommandQueue, we might imagine that even issuing a large number of UTM processes would only result in them being accumulated in the CommandQueue. However, in reality, only up to 128 requests can be accumulated, and once a UTM call touches this limit, the processing is blocked until the UTMs issued earlier are completed.</p>
<h2 id="deadlock-conditions-of-utm">Deadlock Conditions of UTM</h2>
<p>The deadlock of UTM is likely caused by the blocking of UTM processing due to the accumulation of more than 128 UTM processes, as described earlier. This blocking can only be resolved when the previously issued UTM processes are completed on the GPU. Because UTM is a method of <code>ID3D12CommandQueue</code>, the UTM processing will not start until all processes enqueued before the UTM are completed and the fence to start the UTM processing is signaled. If a wait of a fence is set before enqueuing the UTM and it is not resolved, a deadlock is expected to occur.</p>
<p>However, generally, a situation where the wait of a fence is not resolved can lead to a deadlock regardless of the UTM operations, so it cannot be said to be a UTM-specific problem. So, what is unique to UTM is where the blocking to wait for the completion of the previously issued UTM processing is performed.
By examining some memory dumps of processes in UTM deadlock situations, we can see that the blocking occurs during the processing within the <code>syscall</code> in <code>win32u!NtGdiDdDDIUpdateGpuVirtualAddress</code>, which means it is blocking in kernel space.</p>
<p>In the previous chapter, when we traced UTM processing with WinDbg, we confirmed that before reaching this point, the mutex in D3D12Core and the Critical Section in UMD are secured. Additional exclusive processing might also be performed in the kernel space of the GDI layer. If these exclusive processes blocks to signal a wait fence set on the queue before calling the UTM, a deadlock will occur.<br>
It&rsquo;s natural to wonder if such a thing could actually happen. However, in the next chapter, I believe you will be convinced when you see the list of other APIs that are blcoked during UMT blocking.</p>
<h2 id="apis-that-conflict-with-utm">APIs that conflict with UTM</h2>
<p>Let&rsquo;s take a look at other API calls that stops during UTM blocking. The mutex in D3DCore and the critical section in UMD can be observed to conflict with a debugger. However, examining dumps of processes that stopped with UTM deadlocks reveals that exclusive processing also seems to exist in the GDI functions performed in kernel space.
Here, I want to list the functions frequently observed in the dumps of processes where UTM deadlocks occurred, meaning the functions that likely be blocked due to UTM blocking.</p>
<h4 id="id3d12commandqueueexecutecommandlists-1">ID3D12CommandQueue::ExecuteCommandLists</h4>
<p>In my experience, this is most frequently observed. Within D3DCore, the attempt to acquire a mutex fails, causing the thread to sleep and wait in <code>NtWaitForAlertByThreadId</code>. If this mutex is secured by UTM, it is likely bound to the same CommandQueue, so it makes sense that the API call is blocked to acquire the mutex and enter a wait state. So, this ECL should be queued after the UTM, and it shouldn&rsquo;t be the direct cause of a deadlock caused by UTM.</p>
<h4 id="id3d12commandqueuesignal-1">ID3D12CommandQueue::Signal</h4>
<p>This is observed to call <code>NtGdiDdDDISubmitSignalSyncObjectsToHwQueue</code> from D3DCore directly to Win32u and stopped within the <code>syscall</code>. A deadlock should occur if a signal fence set on another queue to signal the wait fence set on the UTM queue cannot be set.<br>
It is really interesting that the thread calling the signal is halted within the <code>syscall</code>.</p>
<h4 id="id3d12fenceseteventoncompletion-1">ID3D12Fence::SetEventOnCompletion</h4>
<p>This API calls the method <code>D3D12Core!CFence::SetEventOnCompletion</code> from <code>D3D12Core!CDevice::SetEventOnMultipleFenceCompletion</code>. Therefore, although the API is classified as <code>ID3D12Fence</code>, it seems more appropriate to consider it as a process of <code>ID3D12Device</code>. Ultimately, it calls <code>NtGdiDdDDIWaitForSynchronizationObjectFromCpu</code> and stooped in the <code>syscall</code>.</p>
<h4 id="id3d12devicecreateplacedresource-1">ID3D12Device::CreatePlacedResource</h4>
<p>In my environment, this method calls <code>D3D12Core!NDXGI::CDevice::UpdateGpuVirtualAddressCB</code> from UMD, and ultimately calls <code>NtGdiDdDDIUpdateGpuVirtualAddress</code>. It follows the same code path as <code>ID3D12CommandQueue::UpdateTileMappings</code>. Since it involves the same kernel call as UTM, it is understandable that it conflicts.</p>
<h4 id="id3d12fencerelease-1">ID3D12Fence::Release()</h4>
<p>The most surprising observation was the release of a fence object. This process ultimately calls <code>NtGdiDdDDIDestroySynchronizationObject</code>. I&rsquo;ve seen the API stopped in the <code>syscall</code> of it multiple times.</p>
<h2 id="how-should-we-avoid-utm-deadlocks">How Should We Avoid UTM deadlocks?</h2>
<h4 id="limit-and-manage-number-of-in-flight-utms">Limit and Manage number of in-flight UTMs.</h4>
<p>There may be some ways to avoid UTM deadlock, but I propose one of the most effective methods. That is to monitor and control the number of UTM issues on the application side. The method involves preparing a dedicated CPU thread, a dedicated copy queue, and a dedicated fence for processing UTMs. After calling a UTM, set a signal and increment its fence value. Before calling UTM, check the completion status on the GPU side with <code>GetCompletedValue()</code>, and if it appears that more than 128 requests are likely to be queued, use <code>SetEventOnCompletion()</code> to wait for the completion of previously issued UTMs. This way, you can prevent more than 128 UTMs from piling up on the command queue. If synchronization with a GraphicsQueue or ComputeQueue is necessary, set a fence between them as needed for synchronization.</p>
<h4 id="why-prepare-a-dedicated-thread">Why Prepare a Dedicated Thread</h4>
<p>First of all, it is natural to prepare a dedicated thread, considering the situation where the thread may need to wait with <code>SetEventOnCompletion()</code>. In addition, the UTM call inherently involves CPU-side fence processing. It is expected that many DPC calls will occur as observed in GPU View. These processings may potentially steal CPU time and disturb L1 cache state from the caller thread. Therefore, the UTM calls should be in a thread specialized for UTM processing.</p>
<h4 id="why-prepare-a-dedicated-copy-queue">Why Prepare a Dedicated Copy Queue</h4>
<p>The primary reason for using a dedicated copy queue is to accurately count the number of UTMs. The condition of UTM blocking with 128 is based on the number per command queue, not the total number issued within the process. As an extreme example, if you prepare two command queues and evenly distribute UTM requests, you can issue up to 256 UTMs.<br>
Preparing a dedicated queue and synchronizing with other queues using a fence might initially seem like a high-overhead process. However, UTM processing inherently involves operations by the OS memory manager and synchronizes with the queue issued by the UTM using a fence. In other words, it is inherently a high-overhead process.<br>
If you synchronize with other graphics queues or compute queues using a fence, those queues will ultimately wait for the UTM queue. The overall throughput may not change. However, if you find that the graphics queue or compute queue is waiting for the UTM queue for a long time, you may want to adjust the timings of the fence synchronizing with the UTM queue, or, insert other non-dependent processes for optimization.<br>
FYI, UTM processing is handled in a very short time on the hardware copy queue on the GPU. This means that during UTM processing, the GPU&rsquo;s compute units are idling. Proper scheduling has a possibility to hide the GPU cost of UTM.</p>
<h2 id="summary">Summary</h2>
<p>In the end, the mechanism behind deadlocks caused by UTM remains speculative. There are other methods to avoid UTM deadlocks, but when UTM blocking occurs, we found that various D3D APIs are blocked. In a multi-threaded program, this means that many threads related to rendering could stall simultaneously. In other words, once UTM blocking occurs, the program is already facing significant performance issues. Therefore, it is not only necessary to avoid UTM deadlocks but also to control the application to prevent UTM blocking itself.
I hope it will be solved in the OS in the future.</p>

    </div>

    






<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/d3d12/">D3D12</a>
  
</div>



<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=https://shikihuiku.github.io/post/d3d12utm/&amp;text=ID3D12CommandQueue::UpdateTileMappings%e3%81%8c%e8%b5%b7%e3%81%93%e3%81%99%e3%83%87%e3%83%83%e3%83%89%e3%83%ad%e3%83%83%e3%82%af%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=https://shikihuiku.github.io/post/d3d12utm/&amp;t=ID3D12CommandQueue::UpdateTileMappings%e3%81%8c%e8%b5%b7%e3%81%93%e3%81%99%e3%83%87%e3%83%83%e3%83%89%e3%83%ad%e3%83%83%e3%82%af%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=ID3D12CommandQueue::UpdateTileMappings%e3%81%8c%e8%b5%b7%e3%81%93%e3%81%99%e3%83%87%e3%83%83%e3%83%89%e3%83%ad%e3%83%83%e3%82%af%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&amp;body=https://shikihuiku.github.io/post/d3d12utm/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=https://shikihuiku.github.io/post/d3d12utm/&amp;title=ID3D12CommandQueue::UpdateTileMappings%e3%81%8c%e8%b5%b7%e3%81%93%e3%81%99%e3%83%87%e3%83%83%e3%83%89%e3%83%ad%e3%83%83%e3%82%af%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="whatsapp://send?text=ID3D12CommandQueue::UpdateTileMappings%e3%81%8c%e8%b5%b7%e3%81%93%e3%81%99%e3%83%87%e3%83%83%e3%83%89%e3%83%ad%e3%83%83%e3%82%af%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%20https://shikihuiku.github.io/post/d3d12utm/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=https://shikihuiku.github.io/post/d3d12utm/&amp;title=ID3D12CommandQueue::UpdateTileMappings%e3%81%8c%e8%b5%b7%e3%81%93%e3%81%99%e3%83%87%e3%83%83%e3%83%89%e3%83%ad%e3%83%83%e3%82%af%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>












  
  





  
    
    
    
      
    
    
    
    <div class="media author-card content-widget-hr">
      
        
        <img class="avatar mr-3 avatar-circle" src="/author/shikihuiku/avatar_hu83bef21d3d3e76bee62dd138e5083bbc_32201_270x270_fill_q90_lanczos_center.jpg" alt="shikihuiku">
      

      <div class="media-body">
        <h5 class="card-title"><a href="https://shikihuiku.github.io/">shikihuiku</a></h5>
        
        <p class="card-text">リアルタイムレンダリングが好き</p>
        <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://twitter.com/shikihuiku" target="_blank" rel="noopener">
        <i class="fab fa-twitter"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/shikihuiku" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
</ul>

      </div>
    </div>
  














  
  
  <div class="article-widget content-widget-hr">
    <h3>Related</h3>
    <ul>
      
      <li><a href="/post/wave_intrinsics1/">HLSLのWave Intrinsicsについて</a></li>
      
    </ul>
  </div>
  





  </div>
</article>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js" integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js" integrity="sha512-7t8APmYpzEsZP7CYoA7RfMPV9Bb+PJHa9x2WiUnDXZx3XHveuyWUtvNOexhkierl5flZ3tr92dP1mMS+SGlD+A==" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/languages/r.min.js"></script>
        
      

    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js" integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin="anonymous"></script>
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    <script>const isSiteThemeDark = false;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks",
        'slides' : "Slides"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.341e58d06db179e1d53f3322b6883f4c.js"></script>

    






  
  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    
  </p>

  
  






  <p class="powered-by">
    
    Published with
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic Website Builder</a>
    

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
