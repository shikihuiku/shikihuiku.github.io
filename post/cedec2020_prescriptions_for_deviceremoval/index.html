<!DOCTYPE html><html lang="en-us" >

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.8.0">

  

  
  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="shikihuiku">

  
  
  
    
  
  <meta name="description" content="CEDEC2020のショートセッションで説明しきれなかった部分についての補足資料になります">

  
  <link rel="alternate" hreflang="en-us" href="https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/">

  


  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  

  
  
  
  
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css" integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin="anonymous">
    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js" integrity="sha256-Md1qLToewPeKjfAHU1zyPwOutccPAm5tahnaw7Osw0A=" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      
        
      

      
    
      

      
      

      
    

  

  
  
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.min.081b4c7fccbd03c601ab1c3cccacd4f9.css">

  




  


  
  

  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/images/icon_hu127225d7ed9c50974404790b7c221374_401884_32x32_fill_lanczos_center_2.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hu127225d7ed9c50974404790b7c221374_401884_192x192_fill_lanczos_center_2.png">

  <link rel="canonical" href="https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/">

  
  
  
  
  
  
  
    
  
  
  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="og:site_name" content="shikihuiku – 色不異空 – Real-time rendering topics in Japanese.">
  <meta property="og:url" content="https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/">
  <meta property="og:title" content="Device Removalの処方箋 - 補足資料 | shikihuiku – 色不異空 – Real-time rendering topics in Japanese.">
  <meta property="og:description" content="CEDEC2020のショートセッションで説明しきれなかった部分についての補足資料になります"><meta property="og:image" content="https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/featured.png">
  <meta property="twitter:image" content="https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/featured.png"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2020-09-04T18:00:00&#43;09:00">
    
    <meta property="article:modified_time" content="2020-09-04T18:00:00&#43;09:00">
  

  


    






  




<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/"
  },
  "headline": "Device Removalの処方箋 - 補足資料",
  
  "image": [
    "https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/featured.png"
  ],
  
  "datePublished": "2020-09-04T18:00:00+09:00",
  "dateModified": "2020-09-04T18:00:00+09:00",
  
  "author": {
    "@type": "Person",
    "name": "shikihuiku"
  },
  
  "publisher": {
    "@type": "Organization",
    "name": "shikihuiku – 色不異空 – Real-time rendering topics in Japanese.",
    "logo": {
      "@type": "ImageObject",
      "url": "https://shikihuiku.github.io/images/icon_hu127225d7ed9c50974404790b7c221374_401884_192x192_fill_lanczos_center_2.png"
    }
  },
  "description": "CEDEC2020のショートセッションで説明しきれなかった部分についての補足資料になります"
}
</script>

  

  


  


  





  <title>Device Removalの処方箋 - 補足資料 | shikihuiku – 色不異空 – Real-time rendering topics in Japanese.</title>

</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class=" ">

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  












<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">shikihuiku – 色不異空 – Real-time rendering topics in Japanese.</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">shikihuiku – 色不異空 – Real-time rendering topics in Japanese.</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-end" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
            
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="https://shikihuiku.wordpress.com/" target="_blank" rel="noopener"><span>Old Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>About</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      <li class="nav-item dropdown theme-dropdown">
        <a href="#" class="nav-link js-theme-selector" data-toggle="dropdown" aria-haspopup="true">
          <i class="fas fa-palette" aria-hidden="true"></i>
        </a>
        <div class="dropdown-menu">
          <a href="#" class="dropdown-item js-set-theme-light">
            <span>Light</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-dark">
            <span>Dark</span>
          </a>
          <a href="#" class="dropdown-item js-set-theme-auto">
            <span>Automatic</span>
          </a>
        </div>
      </li>
      

      

    </ul>

  </div>
</nav>



  <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>Device Removalの処方箋 - 補足資料</h1>

  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    2020/09/04
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    29 min read
  </span>
  

  
  
  

  
  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style">
      <h2 id="これは補完資料です">これは補完資料です</h2>
<p>この記事は、CEDEC2020での講演 &ldquo;Direct3D 12 Device Removalの処方箋&rdquo; において、時間内に説明することができなかった部分に関して解説するためのものです。
CEDEC2020で当該講演を聴講された方に向けて書いています。この記事単体では不完全です。タイムシフト視聴や、CEDiLにアクセス可能な方は、先にそちらをご覧になることをお勧めします。</p>
<h2 id="device_removedとは">DEVICE_REMOVEDとは</h2>
<ul>
<li>
<p>DXGIとD3D12API返すHRESULTに設定されるエラー</p>
<ul>
<li>正式にはDXGIのエラーコード。DXGI_ERROR_DEVICE_REMOVED</li>
<li>殆どの場合は、IDXGISwapChain::Present()呼び出しの際に返される</li>
<li>ID3D12DeviceD3D12の一部のメソッド、リソースの作成、Mapなどを実行した際にも返される</li>
<li>ID3D12Device::GetDeviceRemovedReasonの呼び出しでも返される</li>
</ul>
</li>
<li>
<p>ID3D12Device::GetDeviceRemovedReasonを呼び出すことで以下の様な具体的なエラー原因が取得できる。</p>
<ul>
<li>DXGI_ERROR_DEVICE_HUNG</li>
<li>DXGI_ERROR_DEVICE_REMOVED</li>
<li>DXGI_ERROR_DEVICE_RESET</li>
<li>DXGI_ERROR_DRIVER_INTERNAL_ERROR</li>
<li>DXGI_ERROR_INVALID_CALL</li>
</ul>
</li>
<li>
<p>FormatMessage()や、_com_errorでエラーの意味を取得できる<br>
Device Removed Reason for 887a0006 DXGI_ERROR_DEVICE_HUNG
The GPU will not respond to more commands, most likely because of an invalid command passed by the calling application.</p>
</li>
</ul>
<h2 id="device_removedが発生する原因について">DEVICE_REMOVEDが発生する原因について</h2>
<p>DEVICE_REMOVEDは、D3D12APIを通じて、GPUやドライバーで発生したエラーの結果に過ぎない。OSやD3D12ランタイムが、コンテキストの実行を継続するべきでは無いと判断した場合に発生する。
ただ、
<a href="https://www.youtube.com/watch?v=VaGcs5-W6S4" target="_blank" rel="noopener">Alex DunnがGDC2018で説明</a>した通り、大きく分けて２つの種類にカテゴライズする事ができる。</p>
<ul>
<li>
<p>TDR（Timeout Detection and Recovery）によるDEVICE_REMOVED<br>
ドライバーやGPUがOSに対して一定時間内に応答しなかった場合に、OSが発生させるDEVICE_REMOVED。OSはシステム全体のHungを避けるため、DEVICE_REMOVEDを発生させてドライバーをリセットする。</p>
<ul>
<li>ドライバーのコードパスで想定していない長時間の処理があった場合</li>
<li>シェーダー内で長時間処理がかかった場合（シェーダー内無限ループ等）</li>
<li>Signal,Waitの設定ミスで長時間Fenceが解決しなかった場合</li>
</ul>
</li>
<li>
<p>エラーの検出によるDEVICE_REMOVED<br>
何らかの看過できないエラーの発生に伴いOSやD3D12ランタイムが発生させるDEVICE_REMOVED。</p>
<ul>
<li>GPUで発生したPage Fault
存在しないリソースへのアクセスや、宣言した利用用途と異なるアクセス。</li>
<li>不正な上書き等によるCommand Listの破損
結果的にドライバーやGPUが不正な実行コマンドを受け取る。</li>
<li>D3D12ランタイムやドライバーによるエラーの検出
許可されていないリソースステートのリソースへのアクセス。各種リソースのアラインメント違反。</li>
</ul>
</li>
</ul>
<h2 id="gpuとcpuの時間のずれ">GPUとCPUの時間のずれ</h2>
<p>ここでは、CPUコードのデバッグと、DEVICE_REMOVEDの追跡の決定的な違いについて説明する。
CPUの実行コードは、デバッガがアタッチされている状況下では即時的であり、エラーが発生すれば直ちにプログラムの実行を停止して、デバッガに処理を返すことで、エラーが起きた瞬間の状況が分かる。<br>
これに対して、DEVICE_REMOVEDの発生は、CPUのコードと全く同期しないタイミングで発生する。そのため、CPUがDEVICE_REMOVEDを受け取った瞬間にデバッガで処理を止める事にはほとんど意味がない。</p>
<p>以下のスクリーンショットはGPUViewというツールでCPUとGPUの処理時間を示したものになる。画面左から右に時間の経過を表している。中央の大きなスタックの中でハイライトされているのは、
あるGPU処理の塊となる、バケットである。ご覧の通り画面の左端で生成されたバケットは、画面の右側でスタックの最下段に到達している。この時点GPUの処理の対象となる。この間3フレーム分の時間が経過している。
もし、このGPU処理のなかでDEVICE_REMOVEDが発生したら、CPUがそのエラーを受け取る可能性があるのは、この時点以後となるので、CPUから見るとコマンド生成から3フレーム以上遅れてDEVICE_REMOVEDを受け取る事になる。</p>






  



  
  











<figure class="center" id="figure-gpuとcpuの処理時間のずれ">


  <a data-fancybox="" href="/post/cedec2020_prescriptions_for_deviceremoval/GPUView_Framelatency_clipped_hu8d16dffa687010e8cb8fe6da31428ef9_85614_2000x2000_fit_lanczos_2.PNG" data-caption="GPUとCPUの処理時間のずれ">


  <img data-src="/post/cedec2020_prescriptions_for_deviceremoval/GPUView_Framelatency_clipped_hu8d16dffa687010e8cb8fe6da31428ef9_85614_2000x2000_fit_lanczos_2.PNG" class="lazyload" alt="" width="70%" height="870">
</a>


  
  
  <figcaption>
    GPUとCPUの処理時間のずれ
  </figcaption>


</figure>

<p>これが、DEVICE_REMOVEDの追跡が難しい原因の一つである。</p>
<h2 id="device_removedの対処法">DEVICE_REMOVEDの対処法</h2>
<p>GPU上で発生する様々なエラーをデバッグする方法として、D3D12APIは以下の方法を提供している</p>
<ul>
<li>Debug Layer<br>
昔からあるが、DEVICE_REMOVEDの原因の追跡において最も有効な方法の一つ</li>
<li>GPU Based Validation<br>
比較的新しく導入されたDebug Layerの拡張。CPU側のValidationでは追跡できない問題を検出する</li>
<li>DRED1.2<br>
新しく導入されたDEVICE_REMOVEDの追跡方法</li>
</ul>
<p>上記3つのうち、先の二つは、DEVICE_REMOVEDが発生する前に起きているD3D12上のエラーの追跡に使うのに対して、
DREDは、DEVICE_REMOVEが発生した後に、発生した箇所を見つけ出すためのもので、用途が完全に異なる。どちらも有用なので組み合わせて使う。</p>
<h2 id="debug-layer">Debug Layer</h2>
<p>DEVICE_REMOVEDに対する処方の第一候補は、Debug Layerである。これを有効にすることにより、D3DのランタイムがValidationを積極的に行い、Debug Outputにメッセージを送出するようになる。
DEVICE_REMOVEDが発生する前に出力されるDebug Layerのメッセージは、DEVICE_REMOVEDの発生原因を調査する上での貴重な手がかりになる。</p>
<h3 id="debug-layerの有効化">Debug Layerの有効化</h3>
<p>Debug Layerはアプリケーション自身で有効にすることもできるし、外部から強制的に有効にすることもできる。<br>
外部から強制的に有効にする際は、dxcpl.exe(GUIツール)やd3dconfig.exe(コマンドラインツール)を用いる。インストールはWindows10の、Settings→Add an optional feature→ Add a feature→ Graphics Toolsを選択する事で行う。</p>






  



  
  











<figure class="center" id="figure-dxcplのインストール">


  <a data-fancybox="" href="/post/cedec2020_prescriptions_for_deviceremoval/Graphics_tools_hud17edd7f0016c7970e8d79671c2245cb_50866_2000x2000_fit_lanczos_2.PNG" data-caption="dxcplのインストール">


  <img data-src="/post/cedec2020_prescriptions_for_deviceremoval/Graphics_tools_hud17edd7f0016c7970e8d79671c2245cb_50866_2000x2000_fit_lanczos_2.PNG" class="lazyload" alt="" width="50%" height="930">
</a>


  
  
  <figcaption>
    dxcplのインストール
  </figcaption>


</figure>

<p>外部からDebug Layerを有効にする際は、dxcpl.exeかd3dconfg.exeを用いて、ターゲットとなるアプリケーションの名前を事前に登録し、Debug Layerを強制的に有効にする設定にする。設定内容はdxcplとd3dconfigで共有され、システム全体で有効になるので注意が必要である。</p>






  



  
  











<figure class="center" id="figure-デバッグ対象アプリケーションを登録する">


  <a data-fancybox="" href="/post/cedec2020_prescriptions_for_deviceremoval/Dxcpl_addname_hucbdb74109a3fd183c1975591731fc9c0_227302_2000x2000_fit_lanczos_2.PNG" data-caption="デバッグ対象アプリケーションを登録する">


  <img data-src="/post/cedec2020_prescriptions_for_deviceremoval/Dxcpl_addname_hucbdb74109a3fd183c1975591731fc9c0_227302_2000x2000_fit_lanczos_2.PNG" class="lazyload" alt="" width="50%" height="902">
</a>


  
  
  <figcaption>
    デバッグ対象アプリケーションを登録する
  </figcaption>


</figure>







  



  
  











<figure class="center" id="figure-デバッグ対象アプリケーションを登録する">


  <a data-fancybox="" href="/post/cedec2020_prescriptions_for_deviceremoval/D3dConfg_hu66e5d0a7c318d4262e1366fb00f0e524_17980_2000x2000_fit_lanczos_2.PNG" data-caption="デバッグ対象アプリケーションを登録する">


  <img data-src="/post/cedec2020_prescriptions_for_deviceremoval/D3dConfg_hu66e5d0a7c318d4262e1366fb00f0e524_17980_2000x2000_fit_lanczos_2.PNG" class="lazyload" alt="" width="50%" height="466">
</a>


  
  
  <figcaption>
    デバッグ対象アプリケーションを登録する
  </figcaption>


</figure>

<p>アプリケーション内部で設定する場合は、CreateDeviceを実行する前に、ID3D12Debugインターフェースを取得して、EnableDebugLayer()を呼び出す事で有効にできる。
この場合は、dxcpl.exeやd3dconfig.exeによるターゲットアプリケーション名の登録は必要ない。登録してある場合は、debug-layerの設定はApplication Controlledに設定することでAPIから明示的に有効にした場合のみDebug Layerが有効になる。</p>
<pre><code>// Create Deviceの前に設定する
{
    ComPtr&lt;ID3D12Debug1&gt; debug1;
    if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&amp;debug1))))
    {
        debug1-&gt;EnableDebugLayer();
    }
}
</code></pre>
<h3 id="debug-layerの出力">Debug Layerの出力</h3>
<p>Debug Layerが有効になっている状態では、アプリケーションのD3DAPIの使用において何らかの間違いが検出されれば、エラーの内容がデバッグ出力ストリームに文字列として出力される。出力メッセージはVisual StudioやDbgviewなどのツールを使って確認することができる。出力内容は、その深刻度に応じてグループ分けされている。</p>
<ul>
<li>Info<br>
リソースの確保や開放などを通知する。デフォルトでMuteされている。</li>
<li>Warning<br>
APIの仕様から逸脱していないが、パフォーマンスの問題や、バグの発生の原因になりそうな状況を通知する。</li>
<li>Error<br>
APIの仕様から逸脱した状況が検出された場合に通知する。ただ、これが出力されるから、直ちにDEVICE＿REMOVALが発生するという訳ではない。</li>
<li>Corruption<br>
リソースやオブジェクト（オブジェクト自身というよりは、多くはそのハンドル等）が破損していることが検出された場合に通知する。</li>
<li>Message<br>
上記に当てはまらない情報を通知する（メモリ不足等）</li>
</ul>
<p>以下は、例としてResourceBarrierの遷移前リソースステートの指定が間違っていた場合に出力されたエラーである。ちなみにこのプログラムは、Debug Layerが無効な状態でも有効な状態でも正常に動作した。</p>
<pre><code>D3D12 ERROR: ID3D12CommandList::ResourceBarrier: Before state (0x0: D3D12_RESOURCE_STATE_[COMMON|PRESENT]) of resource (0x000001AE3B886890:'MyColorTex') (subresource: 0) specified by transition barrier does not match with the current resource state (0x400: D3D12_RESOURCE_STATE_COPY_DEST) (assumed at first use) [ RESOURCE_MANIPULATION ERROR #527: RESOURCE_BARRIER_BEFORE_AFTER_MISMATCH]
D3D12 ERROR: ID3D12CommandQueue::ExecuteCommandLists: Using ResourceBarrier on Command List (0x000001AE3B802060:'MyCommandList_Direct'): Before state (0x0: D3D12_RESOURCE_STATE_[COMMON|PRESENT]) of resource (0x000001AE3B886890:'MyColorTex') (subresource: 0) specified by transition barrier does not match with the state (0x400: D3D12_RESOURCE_STATE_COPY_DEST) specified in the previous call to ResourceBarrier [ RESOURCE_MANIPULATION ERROR #527: RESOURCE_BARRIER_BEFORE_AFTER_MISMATCH]
</code></pre>
<p>Debug Layerはこのエラーを二か所で検出した。一つはID3D12CommandList::ResourceBarrier()呼び出し時に、もう一つは、ID3D12CommandQueue::ExecuteCommandLists()呼び出し時に検出した。しかしこれは、この種のエラーは常に二か所で検出されるという意味ではない。コマンドリストは他のコマンドリストの生成タイミングと関係なく生成する事ができ、その際のコマンドリスト作成時のリソースのステートは未確定になる場合がある。そのためDebug Layerは複数の箇所で可能な限りエラーの特定を試みる。上記の場合では、コマンドリスト作成時の対象リソースの事前ステートが確定できたので、ID3D12CommandList::ResourceBarrier()の呼び出し時にエラーが出力出来たという事である。<br>
また、ステートが間違っていたリソースの名前が、&lsquo;MyColorTex&rsquo;といった様に表示されるが、これはアプリケーション自身が、ID3D12Object::SetName()を通じて設定したものである。D3D12アプリケーションを開発し、各種デバッグ機能を使う予定がある場合は、可能な限り全てのD3D12Objectに名前をつけるべきである。すると、上記の様にエラーが発生した際のメッセージによって原因となったリソースの特定が簡単に行えるようになる。Command ListやDescriptor Heapなどにもしっかりと名前を付けると、上記の様にエラーが発生したコマンドリスト名からエラーがどのレンダリングパスで発生したのかが特定できる場合もある。また、PIXやNSightといったフレームプロファイラを使う場合にもこれらの名前付けは有用である。</p>
<p>次の例は、RenderTargetを設定したクリアカラー以外でクリア場合に発生する警告である。これはエラーではないので無視しても構わない。しかし、このようにパフォーマンスの向上を考える場合に有用なメッセージが得られる場合もある。</p>
<pre><code>D3D12 WARNING: ID3D12CommandList::ClearRenderTargetView: The application did not pass any clear value to resource creation. The clear operation is typically slower as a result; but will still clear to the desired value. [ EXECUTION WARNING #820: CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE]
</code></pre>
<h3 id="id3d12infoqueueについて">ID3D12InfoQueueについて</h3>
<p>Debug Layerは、時にはアプリケーションが意図して記述しているコードに対してもメッセージを出力する場合がある。その場合は、アプリケーションが無視するべきと考えるメッセージを、D3D12InfoQueueを使ってフィルタリングできる。以下のコードスニペットは、GPUが書き込みしている可能性のあるリソースがCPUから読み込み可能な状態でMapされている場合に出力される警告を抑制するためのものである。</p>
<pre><code>ComPtr&lt;ID3D12InfoQueue&gt; d3dInfoQueue;
if (SUCCEEDED(device-&gt;QueryInterface(IID_PPV_ARGS(&amp;d3dInfoQueue))))
{
    // Suppress individual messages by their ID.
    D3D12_MESSAGE_ID denyIds[] =
    {
        D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_GPU_WRITTEN_READBACK_RESOURCE_MAPPED,
    };

    D3D12_INFO_QUEUE_FILTER filter = {};
    filter.DenyList.NumIDs = _countof(denyIds);
    filter.DenyList.pIDList = denyIds;
    d3dInfoQueue-&gt;AddStorageFilterEntries(&amp;filter);
    OutputDebugString(L&quot;Warning: GPUTimer is disabling an unwanted D3D12 debug layer warning: D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_GPU_WRITTEN_READBACK_RESOURCE_MAPPED.&quot;);
}
</code></pre>
<blockquote>
<p>Microsoft DirectX SDK Sampleより引用</p>
</blockquote>
<p>メッセージのフィルタリングは、InfoQueueを通じてではなく、dxcpl/d3dconfigを使っても同様のフィルタリングの設定が可能だが、メッセージのフィルタリングはアプリケーションごとに行われるべきであるので、通常はアプリケーションのコードに記述されるべきである。ちなみに、InfoQueueの設定は、dxcpl/d3dconfigの設定でオーバーライドされるので、InfoQueueを使って制御したいときは、dxcpl/d3dconfigにアプリケーションを登録してはいけない。
以下はID3D12InfoQueueのその他の機能についてである。</p>
<ul>
<li>
<p>InfoQueueのデフォルト設定では、Infoレベルのメッセージはフィルタリングされているので、Infoレベルのメッセージを取得する必要がある場合はフィルタの設定を一旦クリアする必要がある。</p>
</li>
<li>
<p>フィルターにはStorageFilterとRetrievalFilterの二種類がある。<br>
StorageFitlerは、エラーがメッセージキューにストアするときに適用されるフィルタ。フィルターを通過できなければ、メッセージキューにストアされない。
RetrievalFilterはメッセージを取得する際に適用されるフィルタ。メッセージキューにストアされているメッセージを破壊せずに、特定の種類のメッセージのみを抽出したいときなどに使う。</p>
</li>
<li>
<p>SetMuteDebugOutputでデバッグ出力ストリームへの出力を停止できる。
アプリケーション側で出力されるエラーのハンドリングを全て行う場合などで、デバッグ出力ストリームへの出力が不要な場合は抑止できる。</p>
</li>
<li>
<p>特定のエラーが検出された時や、エラーの深刻度によって、DebugBreakすることが可能。
Debug LayerはCPU側のD3D12ランタイムがエラーを検出しているので、エラーが発生するタイミングは、CPU処理と同期したタイミングが多い。したがって、DebugBreakすることは有効である。
しかし、DebugBreakがかかるのは、D3Dのランタイム側のスレッドでかかる場合もあるので、追跡するには、マルチスレッドのデバッギングが必要になる。</p>
</li>
</ul>
<h2 id="gpu-based-validationの有効化">GPU Based Validationの有効化</h2>
<p>DEVICE_REMOVEDへの処方の第二候補は、GPU Based Validationの有効化である。GPU Based Validation(以下GBV)は、その名の通り、GPU側での実行時に行うValidationである。
GBVもアプリケーション自身で有効にすることもできるし、dxcplなどで強制的に有効にすることもできる。この点はDebug Layerと同様である。なお、Debug Layerが有効化されていないと動作しないので、Debug Layerの拡張機能と考える事もできる。</p>
<pre><code>{
    ComPtr&lt;ID3D12Debug1&gt; debug1;
    if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&amp;debug1))))
    {
       debug1-&gt;EnableDebugLayer();
       debug1-&gt;SetEnableGPUBasedValidation(true);
    }
}
</code></pre>
<p>先ほど説明したDebug Layerは主にCommandListに命令を積み、ExecuteCommandListを呼び出すまでに行われるValidation。対してGBVはシェーダー実行時に行われるValidationになる。
未定義のDescriptorや、廃棄済みのリソースへのアクセス。不適切なリソースステートでのアクセスなど、CommandList作成時には、リソースの状況が未定で、検出できないエラーを実行時に検出する。
メッセージは既存のDebug Layerと同様に出力されるが、その出力のタイミングはコマンドリストを生成したCPU処理と同期しない。したがって、エラーメッセージが出力された瞬間のCPU処理を検証しても意味がない。</p>
<p>
<a href="https://docs.microsoft.com/sr-latn-rs/windows/win32/api/d3d12sdklayers/ne-d3d12sdklayers-d3d12_message_id" target="_blank" rel="noopener">D3D12_MESSAGE_ID enumeration</a>を確認すれば、GBVで出力されるメッセージのIDには、
&ldquo;GPU_BASED_VALIDATION&quot;が含まれるのが分かる。これで実際にどのようなエラーが検出可能なのか分かる。</p>
<p>GBVは、シェーダーコードとPSOにパッチを充てる形で実現する。これらには、いくつかのモードがあり選択することができる。GBVの設定は以下のAPIと構造体を通じて設定を行う。</p>
<pre><code>ID3D12DebugCommandList1::SetDebugParameter()
typedef struct D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS {
  UINT                                                   MaxMessagesPerCommandList;
  D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE           DefaultShaderPatchMode;
  D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS PipelineStateCreateFlags;
} D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS;
</code></pre>
<p>以下はシェーダーのパッチモードの選択である</p>
<ul>
<li>
<p>NONE<br>
シェーダーコードにValidationコードを挿入しないモード。
CommonStatePromotionによるリソースステートの遷移をトラッキングすることができない。そればかりかGBVを混乱させる恐れがある。</p>
</li>
<li>
<p>TRACKING_ONLY_SHADERS<br>
リソースステートの遷移のみをチェックするためのコードが挿入される。</p>
</li>
<li>
<p>CREATE_UNGUARDED_VALIDATION_SHADERS<br>
GBVのValidationコードが挿入される。Validationによるエラーが検出され、無効なリソースに対するアクセスや範囲外アクセスがあっても該当コードを実行する。結果、DEVICE_REMOVEDなどを引き起こすかもしれない。これがデフォルトのシェーダーパッチモード。</p>
</li>
<li>
<p>CREATE_GUARDED_VALIDATION_SHADERS<br>
GBVのValidationコードが挿入される。Validationによるエラーが検出された場合は、該当のリソースアクセスを避ける。</p>
</li>
</ul>
<p>PipelineStateCreateFlagsでは、事前にPatchされたPSOを生成するかどうかを制御できる。
デフォルトでは、パッチがあてられたPSOの初回使用時にコンパイルされる挙動なので、CommandListのRecordingが遅くなる。FRONT_LOADを設定することで予めコンパイルされる設定になる。</p>
<p>以下はGBVによって検出されたエラーの一例。UAVの範囲外にシェーダーがアクセスしたことで出力された。この種のバグは、CPU側のDebug Layerでは検出できないが、GBVならば検出できる。</p>
<pre><code>DescriptorTableのUAVに設定したUAVバッファに対する範囲外アクセス　(RootSignature1.1を使用。Range Flagは　D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE)
D3D12 ERROR: GPU-BASED VALIDATION: Draw, Resource access out of bounds: Resource: 0x000001C6F8F91A60:'DummyResource_256_bytes_UAV_buffer', Descriptor Type: UAV, Highest byte offset from view start accessed: [439737], Bytes available in view: 256. Results undefined because descriptor is declared static in root signature, which allows hardware/driver the option of converting the access to a root descriptor. Unlike descriptor heap descriptors, root descriptors do not have defined behavior for an out of bounds access. Index of Descriptor Range: 1, Shader Stage: PIXEL, Root Parameter Index: [0], Draw Index: [0], Shader Code: &lt;debug info not available&gt;, Asm Instruction Range: [0xbc-0xdf], Asm Operand Index: [2], Command List: 0x000001C6F8E6DA10:'MyCommandList_Direct', SRV/UAV/CBV Descriptor Heap: 0x000001C6F8D8AB60:'Unnamed ID3D12DescriptorHeap Object', Sampler Descriptor Heap: &lt;not set&gt;, Pipeline State: 0x000001C6F8BC81B0:'Unnamed ID3D12PipelineState Object',  [ EXECUTION ERROR #1005: GPU_BASED_VALIDATION_RESOURCE_ACCESS_OUT_OF_BOUNDS]
</code></pre>
<p>ここで、GBVの話から少しそれるが、このエラーについて詳しく考えてみたいと思う。また、これらの出来事は私のローカル環境で観測されたに過ぎないことも明記しておく。
上記のエラーメッセージを要約すると以下の通りと思われる。</p>
<pre><code>リソースへの範囲外アクセス。リソース：`ummyResource_256_bytes_UAV_buffer` デスクリプタタイプ:UAV 最高でオフセット[439737]にアクセスした。Viewでアクセス可能なのは 256. 
アクセスの結果は未定義です。なぜなら、デスクリプタはRootSignatureで`static`として宣言されており、ハードウェアやドライバーはこの（メモリ）アクセスをルートデスクリプタにコンバートする選択肢が許されているからです。
デスクリプタヒープのデスクリプタと異なり、ルートでスクリプタには範囲外アクセスの挙動の定義がありません。
</code></pre>
<p>このUAVはDescriptorTableに定義したが、RangeFlagに、D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTEを設定した。このフラグが設定されたものはドライバーの最適化対象になる可能性があり、RootDescriptor（RootTableに直接定義するDescriptor）にコンバートされる可能性がある。
実際にコンバートされた場合は、範囲外アクセスは未定義動作となるので、エラーになっているという訳である。しかし、実際はリソースのアクセス範囲チェックがされていた（つまり、RootDescriptorへのコンバートは行われていなかった）ので、DEVICE_REMOVEDが発生するような致命的な事態にはならなかった。</p>
<p>次に、このUAVが設定されているDescriptorTableのRangeFlagに、D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILEを設定するとどうなるかというと、エラーが全く出力されなくなった。これは、DirectXの仕様として、RootSignature1.1のDescriptorTableに定義されたUAVで、D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILEを設定された場合、もしくはRootSignature1.0で定義されたUAVの場合は、リソースアクセスの範囲チェックが行われる決まりがある。範囲外の読み出しはゼロを返され、範囲外への書き込みは行われない。DirectXの仕様に則った動作なのでエラーが発生しないというわけである。</p>
<p>次は、DescriptorTableを介さずに、直接RootTableにUAVを定義して、範囲外アクセスを起こすと以下のメッセージが出力された。</p>
<pre><code>RootTableに設定したUAVバッファに対する範囲外アクセス
D3D12 ERROR: GPU-BASED VALIDATION: Draw, Root descriptor access out of bounds (results undefined): Resource: 0x000001A7600AF410:'DummyResource_256_bytes_UAV_buffer', Root Descriptor Type: UAV, Highest byte offset from view start accessed: [803581], Bytes available from view start based on remaining resource size: 256. Shader Stage: PIXEL, Root Parameter Index: [1], Draw Index: [0], Shader Code: &lt;debug info not available&gt;, Asm Instruction Range: [0xc8-0xeb], Asm Operand Index: [2], Command List: 0x000001A75F82C5B0:'MyCommandList_Direct', SRV/UAV/CBV Descriptor Heap: 0x000001A75F9DEA70:'Unnamed ID3D12DescriptorHeap Object', Sampler Descriptor Heap: &lt;not set&gt;, Pipeline State: 0x000001A75FDC5DE0:'Unnamed ID3D12PipelineState Object',  [ EXECUTION ERROR #961: GPU_BASED_VALIDATION_ROOT_DESCRIPTOR_ACCESS_OUT_OF_BOUNDS]

さらに、DEVICE_REMOVED発生した。
D3D12: Removing Device.
D3D12 ERROR: ID3D12Device::RemoveDevice: Device removal has been triggered for the following reason (DXGI_ERROR_DEVICE_HUNG: The Device took an unreasonable amount of time to execute its commands, or the hardware crashed/hung. As a result, the TDR (Timeout Detection and Recovery) mechanism has been triggered. The current Device Context was executing commands when the hang occurred. The application may want to respawn and fallback to less aggressive use of the display hardware). [ EXECUTION ERROR #232: DEVICE_REMOVAL_PROCESS_AT_FAULT]
</code></pre>
<p>先ほどとエラーメッセージが異なり、エラーのIDが異なるので注意が必要である。以上の出来事をまとめると以下の様になる。</p>
<ul>
<li>DescriptorTableに定義した場合<br>
#1005: GPU_BASED_VALIDATION_RESOURCE_ACCESS_OUT_OF_BOUNDS<br>
こちらのエラーは、VOLATILEでないDescriptorTableに定義されたリソースに対する範囲外アクセスで発生したエラー。
ハードウェアやドライバーが、範囲外アクセスを未定義動作にすることが許されている状態だが、実際に範囲外アクセスをするかは実装次第。</li>
<li>RootTableに直接定義した場合<br>
#961: GPU_BASED_VALIDATION_ROOT_DESCRIPTOR_ACCESS_OUT_OF_BOUNDS<br>
こちらは、DescriptorTableではなく、RootTableに定義されたリソースの範囲外アクセスで発生したエラー。
RootTableにUAVやSRVを定義した場合、リソースのサイズは格納されない事が知られており、通常は範囲外アクセスへのチェックも行われない事が知られている。しかし、GBVを有効にすることでこれらの範囲外アクセスがValidatorにより検出され、
エラーが出力されたという状態。</li>
</ul>
<p>このように、エラーメッセージから学べる事もあるので、Debug LayerやGBVを有効にするのはおすすめである。</p>
<h2 id="debug-layerのその他の機能">Debug Layerのその他の機能</h2>
<h3 id="synchronized-command-queue-validation">Synchronized Command Queue Validation</h3>
<p>Debug Layerを有効にすることで、Synchronized Command Queue Validationという機能がでデフォルトで有効になる。
この機能によって、FenceのWaitが設定されたコマンドリストにおいて、Waitの条件が満たされるまで、GPUへのコマンド送出をしなくなる。
これにより、Waitが設定されている以降のコマンドにおけるリソースステートをCPU側でも確認することができ、結果として、コマンド送出時にリソースステートのValidationをより厳密に行う事ができる。
Disableにすることによって、FenceのSignalとWaitを多用したQueueの組み立てをしている場合に限り、Debug Layer使用時の若干のパフォーマンス向上が期待できるが、そもそもDebug Layerはパフォーマンスを追求するためのものでは無いのでDisableにするメリットは殆どない。</p>
<h3 id="debugdevice--debugcommandqueue--debugcommandlist">DebugDevice / DebugCommandQueue / DebugCommandList</h3>
<p>Debug Layerが有効な状態では、Device, CommandQueue, CommandListからQueryInterfaceすることで、表題のインターフェースが取得できる。
主な機能は以下の通り。</p>
<ul>
<li>ID3D12DebugDevice::ReportLiveDeviceObjects()<br>
現在有効なオブジェクトをデバッグ出力ストリームに出力する。</li>
<li>ID3D12DebugCommandList::AssertResourceState()<br>
リソースのステートが、呼び出し引数に与えたステートと等しいかを返す。<br>

<a href="https://microsoft.github.io/DirectX-Specs/d3d/CPUEfficiency.html#common-state-promotion" target="_blank" rel="noopener">Common State Promotion</a>を使う場合は、これでState PromotionやDecayの確認をするとデバッグしやすい。</li>
<li>ID3D12DebugCommandQueue::AssertResourceState()<br>
リソースのステートが、呼び出し引数に与えたステートと等しいかを返す。<br>
CommandQueuから直接リソースを操作するAPIがある関係上、CommandQueuからもリソースのステートが確認できる。</li>
</ul>
<h2 id="device-removed-extended-data-12">Device Removed Extended Data 1.2</h2>
<p>
<a href="https://microsoft.github.io/DirectX-Specs/d3d/DeviceRemovedExtendedData.html" target="_blank" rel="noopener">Device Removed Extended Data</a>とは、実際にDEVICE_REMOVEDが発生した後に、発生のより詳しい状況を知るための機構である。通常はDEVICE_REMOVEDが発生しても、得られる情報はせいぜいHRESULTのエラーコードぐらいで、デバッグの指標となる情報はほとんどない。しかし、DREDを活用すれば、DEVICE_REMOVEDが発生した時にGPUが実行していたコマンドや、原因となったメモリアクセスについて知ることができる場合がある。
Debug Layerとは機能的に独立しているので、使用にあたりDebug Layerを有効にする必要はない。また、Debug Layerほど処理オーバーヘッドが大きくないので、常時有効にしてアプリケーションを開発することができる。
以下は、DREDの主要機能を有効にするためのコードスニペットである。DRED自体はWindowsSDKの10.0.18362.1より使用可能だが、一部重要な機能が未実装なので、WindowsSDKの10.0.19041.0以後の導入とWindows10 20H1の導入を推奨する。</p>
<pre><code>// Try enabling DRED even in release code
{
  ComPtr&lt;ID3D12DeviceRemovedExtendedDataSettings1&gt; d3dDredSettings1;
  if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&amp;d3dDredSettings1)))) {
    // Turn on AutoBreadcrumbs and Page Fault reporting
    d3dDredSettings1-&gt;SetAutoBreadcrumbsEnablement(D3D12_DRED_ENABLEMENT_FORCED_ON);
    d3dDredSettings1-&gt;SetBreadcrumbContextEnablement(D3D12_DRED_ENABLEMENT_FORCED_ON);
    d3dDredSettings1-&gt;SetPageFaultEnablement(D3D12_DRED_ENABLEMENT_FORCED_ON);
  }
}
</code></pre>
<h3 id="auto-breadcrumbsとbreadcrumb-contextについて">Auto BreadcrumbsとBreadcrumb Contextについて</h3>
<p>Breadcrumbsは、パンくずのことで、所謂通ってきた道を見失わないためにパンくずを撒きながら森の中を歩いた童話にちなんでいる。Auto Breadcrumbsは、明示的にAPIを呼び出してパンを撒かなくても自動的に道標なるイベント（D3D12のAPI呼び出し）を自動的に記録するための機能である。
Auto Bredcrumbsが記録するのは、基本的には、CommandListを介して実行するコマンド群である。詳細は
<a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d12/ne-d3d12-d3d12_auto_breadcrumb_op" target="_blank" rel="noopener">D3D12_AUTO_BREADCRUMB_OP enumeration</a>で確認できる。
そして、DEVICE_REMOVEDが発生する直前に実行したメソッドを指し示すことで、DEVICE_REMOVEDが発生した瞬間にGPUが実行していたオペレーションが分かる仕組みになっている。</p>
<p>しかし、Auto Bredcrumbsは実行したコマンドの種類を記録するだけなので、連続する一連のDrawなどでは、実際にどのDraｗコールが問題を引き起こしたか分からない。
Breadcrumb Contextは、Auto Breadcrumbによって記録されたオペレーションに関連する情報を記録した文字列が取得できるDRED1.2で導入された新しい機能である。
具体的には、Pixのマーカーがセットされた場合は、そのマーカーの文字列が記録される。これにより、大幅にレンダリング箇所の特定が行いやすくなった。</p>
<h3 id="gpu-page-faultについて">GPU Page Faultについて</h3>
<p>GPU Page Faultは、GPU上で発生する不正なメモリアクセスで、これが発生するとDEVICE_REMOVEDとなる。DREDはGPU Page Faultの情報を記録する。まずはGPU Page Faultを理解するためにGPU仮想アドレス空間について簡単に説明する。</p>
<h3 id="gpu仮想アドレス空間について">GPU仮想アドレス空間について</h3>
<p>
<a href="https://docs.microsoft.com/ja-jp/windows-hardware/drivers/display/gpummu-model" target="_blank" rel="noopener">GpuMmu</a>は、WDDM2.0(Windows Display Driver Model 2.0)でサポートされている、主にディスクリートGPU（VRAMとシステムメモリが物理的に独立しているGPU）のための
仮想アドレスモデルである。このモデルでは、プロセスごとに、GPU仮想アドレス空間がCPUの仮想アドレス空間とは別に存在して、物理アドレスに変換するためのMMUも、CPUのMMUとは別に存在している。
GPU仮想アドレス空間は、その名の通りGPU上で実行されるシェーダー等からメモリアクセスをする際に使用されるアドレス空間である。CPU側(D3D12APIやドライバー)でのリソース確保や解放によって、物理メモリが確保または破棄されて、アドレス変換テーブルが更新される。
アドレス変換テーブルが更新される際にはGPU側と同期して、GPU側と同じアドレス変換情報を共有することで、GPU上での仮想アドレスにおけるメモリアクセスを実現している。
図にある通り、物理リソースへのアクセスはアドレステーブルによる変換を介して行う。また、マップされるメモリは、VRAMでもSysMemでも構わない。GPUはどちらに配置されているリソースでも、透過的にアクセスすることができる。</p>
<h3 id="gpu-page-faultが起きるケース">GPU Page Faultが起きるケース</h3>
<p>GPUがPage Faultを起こすのは、アクセスが許されないページにアクセスした場合や、そもそもメモリがマッピングされていないアドレスにアクセスした場合である。主に具体的なケースとして考えられるのは、以下の通りである。</p>
<ul>
<li>DrawcallやDispatch,Copy処理などにおいて、すでに破棄したリソースを参照した場合。</li>
<li>DrawcallやDispatch,Copy処理などにおいて、Evictしたリソースや、Non-Regidentなタイルリソースを参照した場合。</li>
<li>DrawcallやDispatchで、未初期状態のDescriptorTableや、誤ったDescriptorTableを参照した場合。</li>
<li>DrawcallやDispatchで、可変長のDescriptorTableで、シェーダーが実際に配置されているテーブルの範囲を逸脱してアクセスした場合。</li>
<li>DrawcallやDispatchでRootTableに配置したUAVやSRVに対して誤った範囲でアクセスした場合。</li>
</ul>
<h3 id="gpu-page-faultで得られる情報について">GPU Page Faultで得られる情報について</h3>
<p>DREDは、PageFaultが発生したアドレス空間に確保されているオブジェクトが有れば、そのオブジェクト名（SetNameで付けた名前）が記録される。
またAllocationTypeとして、そのアドレス空間に配置されたオブジェクトが、
<a href="https://docs.microsoft.com/en-us/windows/win32/api/d3d12/ne-d3d12-d3d12_dred_allocation_type" target="_blank" rel="noopener">どのような種類であるか</a>を知ることができる。
また、そのアドレス空間を使っていて、直近で解放されたリソースがあれば、そのリソースの情報が取得できる。これは、解放されたリソースに対して、シェーダー等がアクセスした場合に発生するPage Faultを知るのに特に有用である。
しかし、GPU Page Faultはあくまで、GPU仮想アドレス変換時のエラーでしかないので、アクセスしたアドレスに有効なページがあればアクセス自体が成立するため、GPU page faultにならない。したがって、すべての不正アクセスを検出するわけではない。
たとえば、EvictしたリソースはVRAMが特に逼迫した状況になるまではリソースのページアウトが起きないため、そのままVRAM上に配置されていることが多い。結果Page Faultも起きない上に、正しくレンダリングされるため、問題に気づけない。</p>
<h2 id="dredで得られる情報で何が分かるか">DREDで得られる情報で何が分かるか</h2>
<p>DREDは、一見するとDEVICE_REMOVEDの発生原因についての十分な情報を提供してくれるように思えるが実際は違う。
AutoBreadCrumbは、エラーが発生していた時に実行していたコンテキストに過ぎず、実際にエラーの原因がその中にあるとは限らない。
Page Faultも同様で、Page Faultは発生した一つのアクセス例外に過ぎず、何がアクセス例外の原因となったかは分からない。たとえば、それが古いDescriptor Tableを参照したことによるのか、
破損したDescriptor Tableを参照したことによるのか、参照しているリソースを開放してしまったことによるのかは分からない。</p>
<p>しかし、DEVICE_REMOVEDが頻発する状況下では、DREDで複数のクラッシュの情報を集約することは非常に有効である。例えば、もしも、PageFaultがいつも同じリソースとアドレスで発生するとしたら、
プログラムのロジックが安定的な間違いを犯している可能性が高いと考えられる。また、そうではなく、PageFaultがいろいろなリソースやアドレスで発生するとしたら、リソースやDescritorTableを管理しているスレッドと
GPUの実行コンテキストのレースコンディションを調べる価値があると考えられる。AutoBreadCrumbも同様で、毎回同じドローコールでDEVICE_REMOVEDが発生しているならば、
該当ドローコールのロジックや、実行分岐制御に関わる変数やリソースを調べるべきだが、異なるドローコールでランダムにDEVICE_REMOVEDが発生するならば、コマンドリストの破損の可能性が考えられる。</p>
<p>以下はCommandList作成時には存在していたTextureがExecuteCommandListsの前に解放された場合に発生するGPU Page Faultによって発生した、DEVICE_REMOVEDの際に取得できたDREDの情報である。なお、DREDの情報はデバッグ出力ストリームに自動的に出力されないので、
自身でデータにアクセスして、何らかの形で表示する必要がある。</p>
<pre><code>DXGI_ERROR_DEVICE_HUNG
The GPU will not respond to more commands, most likely because of an invalid command passed by the calling application.
==== Auto Breadcrubs ====
QueueNameW: MyCommandQueue
QueuePtr: 0x2bad9c40330
BreadcrumbCount: 0
BreadcrumbContextsCount: 0
LastBreadcrumbValues: 0
==== Auto Breadcrubs ====
QueueNameW: MyCommandQueue
QueuePtr: 0x2bad9c40330
CommandListNameW: MyCommandList_Direct
CommandListPtr: 0x2bad9e379f0
BreadcrumbCount: 7
BreadcrumbContextsCount: 3
LastBreadcrumbValues: 5
  0|D3D12_AUTO_BREADCRUMB_OP_SETMARKER|==Frame Start==
  1|D3D12_AUTO_BREADCRUMB_OP_SETMARKER|Set viewport and render targets
  2|D3D12_AUTO_BREADCRUMB_OP_RESOURCEBARRIER
  3|D3D12_AUTO_BREADCRUMB_OP_CLEARRENDERTARGETVIEW
  4|D3D12_AUTO_BREADCRUMB_OP_SETMARKER|Draw - Triangle
&lt;&lt;&lt;&lt;&lt;&lt;Something wrong happned here...&gt;&gt;&gt;&gt;&gt;&gt;
  5|D3D12_AUTO_BREADCRUMB_OP_DRAWINSTANCED
  6|D3D12_AUTO_BREADCRUMB_OP_RESOURCEBARRIER
====Page fault information ====
PageFaultGPUVA: 0x70fc000
==Existing Allocation Node Info
==Recent Freeed Allocation Node Info
ObjectNameW: DummyResource_256_bytes_UAV_buffer
AllocationType: D3D12_DRED_ALLOCATION_TYPE_RESOURCE
IUnknownPtr: 0x0x2bad9e8f9c0
D3D12app.exe has triggered a breakpoint.
</code></pre>
<h3 id="dump-file-について">Dump File について</h3>
<p>DREDの情報はユーザーモードダンプからも抽出することができる。まずは、
<a href="https://docs.microsoft.com/en-us/windows/win32/wer/collecting-user-mode-dumps" target="_blank" rel="noopener">プロセスがCrashした際に、FullDumpが作られる様に事前に設定</a>し、ダンプファイルをwindbgで読み込む。
windbg.exeはWindows10のSDKに同梱されている。通常は、&ldquo;C:\Program Files (x86)\Windows Kits\10\Debuggers\x64\windbg.exe&quot;に配置されるはずである。
そこで、
<a href="https://github.com/Microsoft/DirectX-Debugging-Tools" target="_blank" rel="noopener">MicrosoftがGitHubで公開しているスクリプト</a>を読み込むことで、DREDの情報に容易にアクセスできる。
手順は該当のリポジトリでも確認できるが非常に簡単である。プロセスがクラッシュした際のフルダンプを読み込み、以下のコマンドを実行するだけである。</p>
<pre><code>.scriptload &lt;&lt;path to script file&gt;&gt;\d3ddred.js
!d3ddred
</code></pre>
<p>以下が、Windbg上で実際にDRED情報を表示した例である。取得できる情報は、DREDのAPIで取得できる情報と同一である。</p>






  



  
  











<figure class="center" id="figure-windbg上でdred12の情報を確認する">


  <a data-fancybox="" href="/post/cedec2020_prescriptions_for_deviceremoval/WinDbg_hu91d4c8ada4e4ee2168dbdfb94cdee135_75072_2000x2000_fit_lanczos_2.PNG" data-caption="Windbg上で、DRED1.2の情報を確認する">


  <img data-src="/post/cedec2020_prescriptions_for_deviceremoval/WinDbg_hu91d4c8ada4e4ee2168dbdfb94cdee135_75072_2000x2000_fit_lanczos_2.PNG" class="lazyload" alt="" width="70%" height="1011">
</a>


  
  
  <figcaption>
    Windbg上で、DRED1.2の情報を確認する
  </figcaption>


</figure>

<h3 id="最後に">最後に</h3>
<p>これら全てを駆使しても簡単に判明しないDEVICE_REMOVEDも存在すると思うが、DEVICE_REMOVEDを手さぐり的に解決する時代は終わりを迎えようとしていると言えると思う。</p>

    </div>

    






<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/dx12/">DX12</a>
  
  <a class="badge badge-light" href="/tag/debug-layer/">Debug Layer</a>
  
  <a class="badge badge-light" href="/tag/gbv/">GBV</a>
  
  <a class="badge badge-light" href="/tag/dred/">DRED</a>
  
</div>



<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/&amp;text=Device%20Removal%e3%81%ae%e5%87%a6%e6%96%b9%e7%ae%8b%20-%20%e8%a3%9c%e8%b6%b3%e8%b3%87%e6%96%99" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/&amp;t=Device%20Removal%e3%81%ae%e5%87%a6%e6%96%b9%e7%ae%8b%20-%20%e8%a3%9c%e8%b6%b3%e8%b3%87%e6%96%99" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=Device%20Removal%e3%81%ae%e5%87%a6%e6%96%b9%e7%ae%8b%20-%20%e8%a3%9c%e8%b6%b3%e8%b3%87%e6%96%99&amp;body=https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/&amp;title=Device%20Removal%e3%81%ae%e5%87%a6%e6%96%b9%e7%ae%8b%20-%20%e8%a3%9c%e8%b6%b3%e8%b3%87%e6%96%99" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="whatsapp://send?text=Device%20Removal%e3%81%ae%e5%87%a6%e6%96%b9%e7%ae%8b%20-%20%e8%a3%9c%e8%b6%b3%e8%b3%87%e6%96%99%20https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=https://shikihuiku.github.io/post/cedec2020_prescriptions_for_deviceremoval/&amp;title=Device%20Removal%e3%81%ae%e5%87%a6%e6%96%b9%e7%ae%8b%20-%20%e8%a3%9c%e8%b6%b3%e8%b3%87%e6%96%99" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>












  
  





  
    
    
    
      
    
    
    
    <div class="media author-card content-widget-hr">
      
        
        <img class="avatar mr-3 avatar-circle" src="/author/shikihuiku/avatar_hu83bef21d3d3e76bee62dd138e5083bbc_32201_270x270_fill_q90_lanczos_center.jpg" alt="shikihuiku">
      

      <div class="media-body">
        <h5 class="card-title"><a href="https://shikihuiku.github.io/">shikihuiku</a></h5>
        
        <p class="card-text">リアルタイムレンダリングが好き</p>
        <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://twitter.com/shikihuiku" target="_blank" rel="noopener">
        <i class="fab fa-twitter"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/shikihuiku" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
</ul>

      </div>
    </div>
  














  
  





  </div>
</article>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js" integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js" integrity="sha512-7t8APmYpzEsZP7CYoA7RfMPV9Bb+PJHa9x2WiUnDXZx3XHveuyWUtvNOexhkierl5flZ3tr92dP1mMS+SGlD+A==" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/languages/r.min.js"></script>
        
      

    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js" integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin="anonymous"></script>
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    <script>const isSiteThemeDark = false;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks",
        'slides' : "Slides"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.66c553246b0f279a03be6e5597f72b52.js"></script>

    






  
  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    
  </p>

  
  






  <p class="powered-by">
    
    Published with
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic Website Builder</a>
    

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
