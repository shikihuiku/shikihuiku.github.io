<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Memos | shikihuiku – 色不異空 – Real-time rendering topics in Japanese.</title>
    <link>https://shikihuiku.github.io/memo/</link>
      <atom:link href="https://shikihuiku.github.io/memo/index.xml" rel="self" type="application/rss+xml" />
    <description>Memos</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 11 Sep 2020 11:59:35 +0900</lastBuildDate>
    <image>
      <url>https://shikihuiku.github.io/images/icon_hu127225d7ed9c50974404790b7c221374_401884_512x512_fill_lanczos_center_2.png</url>
      <title>Memos</title>
      <link>https://shikihuiku.github.io/memo/</link>
    </image>
    
    <item>
      <title>Importance Resampling For Global Illumination</title>
      <link>https://shikihuiku.github.io/memo/restir/</link>
      <pubDate>Fri, 11 Sep 2020 11:59:35 +0900</pubDate>
      <guid>https://shikihuiku.github.io/memo/restir/</guid>
      <description>&lt;h3 id=&#34;参考資料&#34;&gt;参考資料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Importance Resampling for Global Illumination&lt;br&gt;
&lt;a href=&#34;https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1662&amp;amp;context=etd&#34;&gt;https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1662&amp;amp;context=etd&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rendering Millions of Dynamic Lights in Real-Time&lt;br&gt;
&lt;a href=&#34;https://news.developer.nvidia.com/rendering-millions-of-dynamics-lights-in-realtime/&#34;&gt;https://news.developer.nvidia.com/rendering-millions-of-dynamics-lights-in-realtime/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;resampled-importance-sampling&#34;&gt;Resampled Importance Sampling&lt;/h1&gt;
&lt;h2 id=&#34;resampled-importance-samplingの手法&#34;&gt;Resampled Importance Samplingの手法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;確率分布$p$に基づいたM個($(M \ge 1$)のサンプル、$(X = \langle X_1, X_2, &amp;hellip; , X_M \rangle $を生成する&lt;/li&gt;
&lt;li&gt;各サンプルのウエイト$ｗ_j$を計算する&lt;/li&gt;
&lt;li&gt;$X$のなかから、一つのサンプル$Y$を、ウエイト$\langle w_1, w_2, &amp;hellip; , w_M \rangle$に基づいて選ぶ&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;もし、$w_j = \frac{g(X_j)}{p(X_j)}$としたならば、サンプル$Y$は、おおよそ$g$に基づいて分布する。
上記のリサンプリングの効果とは、密度$p$のソースのから、サンプルを取り出し、&amp;ldquo;filter&amp;quot;することで、
結果として、サンプル$Y$がおおよそ$g$の分布になるようにすることである。&lt;/p&gt;
&lt;p&gt;サンプル数である$M$を分布の補間変数としてとらえることができる。
$M=1$のとき、$Y$は$p$に従って分布する。$M\rightarrow\infty$とすると、$Y$の分布は$g$に近づく。
一般的には、$M$が有限個である事によって導入されるバイアスを無視できる程度に小さくするためには、$M$は非常に大きくなけれならない。&lt;/p&gt;
&lt;h2 id=&#34;resampled-importance-samplingの概要&#34;&gt;Resampled Importance Samplingの概要&lt;/h2&gt;
&lt;p&gt;下記の積分を求めたいとする。
$$ I = \int_{\Omega} f(x) d\mu(x) $$&lt;/p&gt;
&lt;p&gt;二つの確率密度関数$p$と、確率に即した値を返す関数$g$を導入する。
$p$は、比較的簡単に計算でき、正規化することができるが、上記積分をImportance Samplingするのにあまり良い分布となっていないとする。
$g$は、良い分布特性を持っているが、計算が複雑で正規化されていない、またはするのが困難だとする。
通常のImportance Samplingでは、$p$を使う事しかできないが、RISを使うことで、$g$の分布特性をunbiasedな条件下で使うことができる。
RISのEstimatorは以下の通りとなる。&lt;/p&gt;
&lt;p&gt;$$ \hat I_{ris} = \frac{1}{N} \sum^{N}_{i=1} w(X_i, Y_i) \frac{f(Y_i)}{g(Y_i)} $$&lt;/p&gt;
&lt;p&gt;ウエイト関数$w$は、$g$が正規化されていないことと、$Y$の分布が$g$を近似するようにする必要があることの二つを考慮して選択されなければならない。
そのための適切なウエイト関数$w$は実は非常に単純で、リサンプリングステップで計算された重みの平均である。&lt;/p&gt;
&lt;p&gt;$$ w(X_i, Y_i) = \frac{1}{M} \sum^{M}_ {j=1} w_ {ij} = \frac{1}{M} \sum^{M}_ {j=1} \frac{g(X_{ij})}{p(X_{ij})}$$&lt;/p&gt;
&lt;p&gt;注釈：$X_i$, $Y_i$はそれぞれが、Importance Samplingの$i$番目の試行の時に作られた、M個のサンプル集合$X_i$と、そこから選択された一つのサンプル$Y_i$を指す。
$w_{ij}$は、Importance Samplingの$i$番目の試行の時に作られた、M個のサンプル集合の、$j$番目のサンプルのウエイトを指す。&lt;/p&gt;
&lt;p&gt;上記の2式を合わせると下記の通りになる。
$$ \hat I_{ris} = \frac{1}{N} \sum^{N}_ {i=1} \left( \frac{f(Y_i)}{g(Y_i)} \cdot \frac{1}{M} \sum^{M}_ {j=1} \frac{g(X_{ij})}{p(X_{ij})} \right) $$&lt;/p&gt;
&lt;p&gt;$M=1$のときは、RISは$p$によるImportance Samplingになる。RISがunbiasedである条件は、$f$が非ゼロの領域では、$p, q$共に非ゼロである必要があるのと、$M,N$共にゼロより大きい必要がある。
RISがunbiasとすると、誤差は分散に起因するもののみとなる。ターゲット分布関数$g$と共に、パラメーター$M,N$を適切に選ぶことが分散の低減につながる。&lt;/p&gt;
&lt;p&gt;レンダリングにおいて、ライティングの関数を$f=F_s GVL_e$とするとき、ターゲット分布関数$g$を、$g=F_s GL_e$とすることができる。レイのトラバースが必要な$V$項を取り除いたものである。正規化されている必要がないのでそのまま使用できる。
次は、適切な$M,N$の設定である。&lt;/p&gt;
&lt;h2 id=&#34;robust-approximations-of-m-and-n&#34;&gt;Robust Approximations of M and N&lt;/h2&gt;
&lt;p&gt;詳細は割愛するが、最適なM,Nを選ぶための計算には、実際のモンテカルロ法の試行が必要になる。しかし実際にはモンテカルロ法の試行の前に知りたい。
ここではサンプルの生成や実際の推定値の計算にかかる時間を基にして、$M,N$の導出を行う。
$T_x$を$p$に基づいてサンプルを生成してウエイトを計算するのにかかる時間とし、$T_y$をIRS Estimatorで推定値を計算する時間とすると、全体の計算時間は以下の様になる。
$$ T=MNT_x + N(r(M) + T_y) $$
$r$はリサンプリングにかかる時間で、離散的な分布からサンプルを選ぶ作業は高度に最適化されており、時間は無視できるとすると以下の様になる。
$$ T=MNT_x + NT_y　$$&lt;/p&gt;
&lt;p&gt;ここで、リサンプリングの各ステップに同じ計算時間を割り当てるとすると、以下の様になる。
$$MNT_x = NT_y $$&lt;/p&gt;
&lt;p&gt;この条件下では$M$は以下の様に求まる。
$$M=\frac{T_y}{T_x} $$&lt;/p&gt;
&lt;p&gt;注釈：$N$は上式から求まらないが、総計算時間の関数として計算することができる。$M$は、$T_y$($V$項を含んだシェーディングの評価)が、他の項の計算に比べてどのくらい時間がかかるかによって
決定されるといえると思う。時間がかかればかかるほど$M$を大きくした方が良いという事になる。&lt;/p&gt;
&lt;p&gt;レンダリングするシーンの複雑度が均一であれば、この値は事前計算することができる。$T_x, T_y$を得るために数千のPrimaryRayをキャストして計算する。&lt;/p&gt;
&lt;p&gt;参照論文のレンダリングの例では、二つのポリゴンライトと環境マップを用いてライティングしている。この場合RISは同じ計算量で分散を70%低減できた。しかし、ライティングから環境マップを取り除くと、分散を10%しか低減出来なかった。
これは、$L_e$の成分にあった環境マップが分散を導入していたからで、これはターゲット分布関数$g$のウエイトとして計算されていた。(つまり$L_e$が導入した分散に効果的に作用した。)
しかし、これが取り除かれると、$V$項による分散が支配的となり、通常のImportance Samplingとの差が得られなくなった。&lt;/p&gt;
&lt;h1 id=&#34;weighted-reservoir-sampling&#34;&gt;Weighted Reservoir Sampling&lt;/h1&gt;
&lt;p&gt;上記Resampled Importance Samplingは、計算時に$M$個のサンプルストリームを用意する必要があった。これを、実際にストレージを確保して保存することなく実現するための手法がWeighted Reservoir Samplingになる。
WRSではサンプルストリームに値を追加するたびにDraw（分布に基づく乱択）を行う代わりに、ストリームに何個要素を追加しても、ウエイトの合計値である$w_ {sum}$と現在の出力である$y$のみ記録することでRISと同等の機能を実現する。&lt;/p&gt;
&lt;h2 id=&#34;weighted-reservoir-samplingの手法&#34;&gt;Weighted Reservoir Samplingの手法&lt;/h2&gt;
&lt;p&gt;以下はWRSのpuseudo codeである。サンプルストリームの要素の追加(update)のたびに、$w_ {sum}$を更新しつつ乱択を行う。Reservoirは常に選択候補となる一つのサンプルを保持する形となる。同じストリームから複数のサンプルを乱択することは出来ないが、必要なストレージが非常に少ないのが特徴。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Reservoir
  y ← 0 // The output sample
  w ← 0 // The weight for the output stream
  wsum ← 0 // The sum of weights
  M ← 0 // The number of samples seen so far

  function p(x)
    return probability of x

  function g(x)
    return target distribution of x

  function update(xi, wi, cnt)
    wsum ← wsum + wi
    M ← M + cnt
    if rand() &amp;lt; (wi /wsum) then
      y ← xi

  function reservoirSampling()
    Reservoir r
    for i ← 1 to StreamLen do
      generate xi
      r.update(xi, g(xi)/p(xi), 1)

    w ← (1 / g(y))(wsum / M)
    return y, w
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;combine-multiple-reservoirs&#34;&gt;Combine Multiple Reservoirs&lt;/h2&gt;
&lt;p&gt;WRSの特長として、個々のストリームにアクセスすることなく、生成された複数のストリームを結合することができることが挙げられる。結合の方法は以下の通りで新しいReservoirに、結合するReservoirを入力することで行う。
s.update()の第二引数のウエイトは、結合する際のReservoirのターゲット分布関数$g$が同じ場合は、r.wsumと等価である。しかし、結合する際のReservoirのターゲット分布関数が異なる場合、 $g(y)/g&amp;rsquo;(y)$をr.wsumに乗算する必要がある。
これはそのための計算である。&lt;/p&gt;
&lt;p&gt;注釈：実際には、結合先と結合元で、確率密度関数や、ターゲット分布関数が異なれば、算術的には正しい結合にならないはずである。ただ、これによってBiasが導入されるかは別である。
実際は、結合後に選択されたサンプルが、結合元の確率密度関数でゼロになる場合にBiasが導入されることになる。この場合は、無効なウエイト値が計算に入るので、実際の値より小さくなる方向にBiasがかかるはずである。
それ以外では、結果的に分散を大きくするかもしれないが、biasが導入されることはない。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function combineReservoirs(g, r1, r2, . . . , rk)
  Reservoir s // a new reservor
  s.g ← g // set a new target distribution

  foreach r ∈ {r1, . . . , rk } do
    s.update(r.y, g(r.y) · r.w · r.M, r.M)

  w ← (1 / g(s.y))(s.wsum / s.M)
  return s.y, w
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;unbiased-combine&#34;&gt;Unbiased combine&lt;/h2&gt;
&lt;p&gt;UnbiasedなWRSの結合をするためには、結合前のターゲット分布関数もしくは、確率密度関数が必要になる。（あるサンプルに対して正の値を返すかどうかチェックするだけなので、実際の関数のプロファイルは関係ない）
ただし、PDFがゼロに近い領域では、結合したRISのウエイトが不安定な値になるので、ターゲット分布関数を用いる方が良い。（これについては長い説明が論文中でなされている）
Reservoirを結合してサンプルの選択をするところまでは同じだが、最後に、選択されたサンプルが、結合前のターゲット分布関数で有効であるかどうかを確認して、無効であればウエイトから除外するようにしている。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function combineReservoirsUnbiased(g, r1, r2, . . . , rk, g1, g2, . . . , gk)
  Reservoir s // a new reservor

  s.combineReservoirs(g, r1, r2, . . . , rk)

  Z ← 0
  foreach gi ∈ {g1, . . . , gk } do
  if gi(s.y) &amp;gt; 0 then
    Z ← Z + ri.M

  w ← (1 / g(s.y))(s.wsum / Z)
  return s.y, w
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
